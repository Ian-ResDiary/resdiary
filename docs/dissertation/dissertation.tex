% This example An LaTeX document showing how to use the l3proj class to
% write your report. Use pdflatex and bibtex to process the file, creating 
% a PDF file as output (there is no need to use dvips when using pdflatex).
% Modified 

% This dissertation was built upon base template provided.

\documentclass{l3proj}

\begin{document}

\title{Team I: ResDiary Restaurant Recommendation System}

\author{Vladimir Bardarski \\
        Paulius Dilkas \\
        Domantas Jurkus \\
        Eduard Kalfov \\
        Josh O'Brien \\
		Joseph O'Hagan}

\date{31st March 2017}

\maketitle

% ##################################################
% LAST EDIT: 	06/03/17	Joseph
% ################# Comment Log ####################
% ##################################################
\begin{abstract}
The abstract shall go here! Here is some things to keep in mind while writing it.
\end{abstract}

\begin{itemize}
\item The abstract is likely the first substantive description of your work read by an examiner. View it as an opportunity to set accurate expectations.
\item The abstract is a summary of the whole thesis. It presents all the major elements of your work in a highly condensed form. (Write it having written the rest of the paper) The paper sets the abstract.
\item It must be capable of substituting for the whole paper when there is insufficient time and space for the full text.
\item Keep it short and snappy. 
\item The primary function of your thesis (and by extension your abstract) is not to tell readers what you did, it is to tell them what you discovered.
\item Approximately the last half of the abstract should be dedicated to summarizing and interpreting your results.
\item The most common error in abstracts is failure to present results.
\end{itemize}

% Comment out this line if you do not wish to give consent for your work to be distributed in electronic format.
% We hereby give consent - spread the knowledge - pending on result of project
\educationalconsent
\newpage

%==============================================================================

% ##################################################
% LAST EDIT: 	06/03/17	Josh
% ################# Comment Log ####################
% 	A. 	We mention the integration but the final 
%		state of the system is for it to be used
%		as a proof of concept / prototype by RD.		<--	Joseph 
% ##################################################
\section{Introduction}
\label{sec:intro}
% An introduction, explaining the purpose of the document, a very brief outline of the project and a summary of the structure of the rest of the document (approximately 1-2 pages).

The Professional Software Development (PSD3) course at The University of Glasgow requires students to engage with the practices and methodologies used in modern large-scale software engineering. The purpose of this dissertation is to document the development of the software project created as part of this course by Team I. 

% ---------- A ----------
The project was to build, over the course of several months, a recommendation engine for the Glasgow-based company ResDiary.
The main deliverable was a system capable of producing sensible restaurant recommendations for existing ResDiary users; a system that could be integrated into the existing ResDiary platform at a later date. 

Our team consisted of six third-year Computing Science students. Within the group there was a broad range of skills, interests and experience - with two members actively working as software professionals, and another having participated in an internship. For some members, however, this was a first opportunity to interact with a real client. 

In this document we outline, in detail, the entire process: from the initial requirements gathering with our customer, through to final system delivery. 

In section \ref{sec:background} we present the background to the project, the motivations of the customer and how we arrived at the agreed deliverables.

%this will surely be expanded to enumerate each separate section better I would like to discuss in detail the practices, issue-tracking, the team work/team load - Josh etc.

In subsequent sections \ref{sec:alice} through Section \ref{sec:reflections} we explore the challenges we faced through development and the steps we took to resolve them, explore the impact of team dynamics on the outcome and reflect on what we have learned from the experience. We also explain how we applied the good development practices learned in PSD3. In particular we highlight the role of version control, agile development and issue tracking.

\newpage

%==============================================================================

\section{Case Study Background}
\label{sec:background}
% A description of the case study background and context. This should include a description of the project customer (what was the nature of the organisation you were working for), their objectives for the project, and a summary of what was actually achieved. Where appropriate, this section should also make reference to similar related projects in order to make the context clear (approximately 4-5 pages).

\subsection{Customer}
\label{sec:customer}
% ##################################################
% LAST EDIT: 	18/03/17	Josh
% ################# Comment Log ####################
% ##################################################

% The customer organisation and background.

% Here we want answer the question of who are ResDiary and what do they do.
% Additionally answer who played the customer role of ResDiary to us on the project.

% Who are ResDiary?
ResDiary are a Glasgow-based online restaurant reservation service; a commercial organisation providing a comprehensive, easy to use booking and table management platform for use by the hospitality industry. The company provides 24-hour reservation services through both social media and their own booking portal ResDiary.com. Diners can browse restaurants, book tables and place reviews. Restaurants can access tools which let them optimize their yields, manage their reservations and attract new diners. Their global service sees 9.7 million bookings every month, and their platform is used by over 6,500 restaurants across 58 countries. 

ResDiary senior software engineers Adam Connelly and Ian Strachan acted as customer representatives throughout the duration of the development. They helped us understand the company line-of-thought behind the project, in addition to providing useful feedback, answering queries and supplying the team with the anonymised ResDiary booking data we required.


\subsection{Customer Objectives And Rationale}
\label{sec:custobjectives}
% ##################################################
% LAST EDIT: 	23/03/17    Joseph
% NOTE: 		Reference papers on Amazon / Netflix Models / Netflix Prize
% NOTE:         Added more specifics on Netflix Recommendations - make sure to tie in to our final output
%               Need to demonstrate that the research was RELEVANT
% ################# Comment Log ####################
%   Really explain why the project is beneficial to the customer - why would recommendations increase business, etc. - this was question / critique of project motives section of the presentation -- Joseph  
% ##################################################

% The rationale and initial objectives for the project.

% Initial Meeting and the customer's motivation for the project.

The initial customer meeting occurred on October 19th and was led by Ian Strachan. This was our first contact with the customer and served as the customer requirements elicitation meeting. The meeting began with an overview of the ResDairy business \ref{sec:customer}, a discussion of the services they provide and an explanation of their technology stack. The ResDiary daily operation involves gathering large quantities of valuable customer data. This collection of big data, however, is currently unused beyond supporting basic business needs (i.e. retrieving booking records). The developers view this as a significant shortcoming of their system.

As such, therefore, the company is exploring potential ways to exploit this vast quantity of valuable data. The developers had conducted some research into the area, and discovered that none of their competitors currently offer a restaurant recommendation service within their booking platform. Thus, if they were able to develop a system which would make recommendations to users based on their previous dining habits and similarity to other users, they would gain a competitive edge. It would also help increase restaurant discovery on their platform, which is beneficial to both restaurants and potential clientele. 

The inspiration for the idea stems from the similar system provided by online services such as Amazon and Netflix, which push recommended products and films respectively to their users. The Netflix model, in particular, was the closest reference point for the system they wished to develop. A parallel between making recommendations based on a user's film history and their similarity to other users, and a similar recommendation engine using ResDiary's dining history is easy to see. As a starting point for our own research, they suggested looking into the Netflix Prize - a competition held by Netflix starting in 2006 challenging participants to better their own recommendation algorithm. 

The goal of the algorithm was to accurately predict a user's rating of a film based solely on previous user ratings and no additional information about either the users or films. A set of training data (a subset of Netflix's real user data) with half a million user ratings was provided to participants, with the algorithm using this data to predict user ratings for a disjoint subset of the user data. No information other than user ID, film ID and date of rating was provided. Our Resdiary project followed a similar structure. ResDiary's users, as with Netflix's, leave review scores ranging from 1 to 5. We were given a subset of their user data which we split into further subsets for training and for evaluation. The research provided an excellent springboard from which to launch our own collaborative filtering model. With such a strong similarity between the requirements of our system and theirs, it was a natural choice.

We also spent time discussing what the customer viewed as the end state of the system - whether it would be integreated into the existing ResDiary portal or whether the output would suffice as a proof-of-concept prototype. They were initially undecided in this regard, partially due to an internal transition in their own development frameworks, and thus suggested our initial aim should be to focus on the creation of the recommendation engine. The decision regarding the final state of the project ultimately would not be made until midway through the development cycle when the customer decided to view the project as simply a proof-of-concept. Nonetheless, at all points during development, due consideration was given to the future integration of our system with ResDiary. 


\subsection{Project Scoping}
\label{sec:ourinitobjectives}
% ##################################################
% LAST EDIT:  18/03/17  Josh
% NOTE:         JOSH: Expanded on importance of requirements.
% NOTE:         References: importance of requirements gathering, cost of making corrections 
% ################# Comment Log ####################
% If required (page count) maybe cut down requirements engineering and incorporating customer 
% feedback in reflection point - we did it pretty well though so there wasn't much to improve
% ##################################################

The risks and costs associated with a project of this nature demand thorough background investigation and cogent planning before development proper commences. The cost of correcting errors grows enormously in the latter stages of a software project.

Our first major task was to formalise our discussions with the client and produce a requirements specification to serve as a project proposal document. The goal was to have a clear outline of the scope of the project and a set of deliverables to present to the client at the next meeting on November 16th. Our requirements gathering occurred in tandem with conducting the necessary initial background research on machine learning and recommendation systems. 

The proposal document included an array of requirements that the team agreed upon, based on our interpretation of the customer's initial project pitch. It was important that our requirements were reasonably comprehensive and realistic, but we accepted that they would be continually revised and refined as the project developed. 

\subsubsection{Initial functional requirements:}
\begin{itemize}
\item The recommendation engine must accurately suggest restaurants based on the users' dining history and similarity to other users with similar eating preferences.
\item Recommended restaurants should be in close proximity to where the user typically eats or the geographical location of where they are currently searching.
\item The recommendation engine may recommend restaurants that  the user has previously visited should the user allow this option.
\end{itemize}

\subsubsection{Initial nonfunctional requirements:}
\begin{itemize}
\item The engine should be written to allow for easy integration into the existing ResDiary system.
\item The system should give a response within one second after receiving the request (provided data is stored locally).
\item New users should be presented an optional quick questionnaire to gather initial data.
\item User and restaurant locations should be interpreted using coordinates rather than city name as those are of arbitrary precision within the dataset.
\end{itemize}

To help us understand the actual scenarios in which the system might be used, we prepared a set of user stories (ranked by priority). They provided a quick, intuitive way to ensure we had covered all the conceivable use cases the customer may require. We also prepared a high-level system UML diagram and a step-by-step work-flow of how the system would generate the actual recommendations. Due to the customer's ambiguity regarding the final state of the system, the endpoint was left intentionally vague to allow for flexibility. Instead the emphasis was to build and produce the most accurate recommendation for a given user. 


\subsection{Refinement of Requirements}
\label{sec:custrefineinitobj}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Needs reworking
% NOTE:			Needs referencing
% ################# Comment Log ####################
% If required (page count) maybe cut down requirements engineering and incorporating customer feedback in reflection point
% ##################################################

% The suggested alternative was to use a nightly build system which the team would utilise in the final version of the system (!R! REFERENCE TO SPARK REFLECTION !R!).

At the November 16th meeting we presented and discussed our project proposal with the customer.

They felt we had a good understanding of their vision. They broadly agreed with the proposed requirements and could envision how our high level system would operate (and potentially integrate into their existing one). We briefly explained that there were two major models for building recommendation systems: collaborative-based filtering and content-based filtering. The high level system architecture accounts for this by allowing multiple 'recommenders' to each implement a different approach to producing recommendations. These recommendations are then combined and filtered for the final output. The customer expressed strong interest in the potential of "fine tuning" this system, through altering the significance placed on individual recommenders. 

There were, of course, areas of concern. Our proposed response rate of one second to respond to a request was queried. They felt that they needed to further clarify the volume of data the system would be expected to work with in a real world deployment. This may put a constraint on our ability to realise that performance. We discussed the alternative of using a nightly build system, as this how they expected the system would operate in a real world setting. In addition, they recommended developing a lightweight front-end application to display the recommendations. This would be a lightweight app, rather than any actual integration with their system, but they rationalised its throwaway nature by suggesting it would help them better understand our system, assist with demonstrating its functionality and most importantly provide a clear indication it was producing sensible results. 

We made modifications to the specification document to incorporate the customer feedback. In particular, the team felt the need to revise the non-functional requirements of the project. The disputed "one second local response rate" requirement was rescinded and in its place we inserted two new requirements:

\begin{itemize}
\item Provided the data is not stored locally, the system should be set up to allow for nightly updates to the recommendations.
\item Have the ability to “fine tune” the recommendation engine by altering the weighting significance of different components of the recommendation such as distance, price, 
reviews, etc.
\end{itemize}

Furthermore, a soft goal developed within the team to produce a more comprehensive front end application to showcase the recommendation system. While some members felt this justified being included and defined formally within the specification document, the majority instead felt the focus of the project should be on creating the most accurate recommendations. We elected to delay defining an exact end state until the customer clarified exactly what they required. We agreed, eventually, that should clarify not be forthcoming, we would press for clarity on the issue during the scheduled January 26th meeting, and define an agreed handover state for the project. 

While some of the team felt this justified being defined within the specification the majority instead felt the focus of the project should be on creating the most accurate recommendations and delay defining an end state until it was defined by the customer. Should the customer not provide clarity earlier it was decided to press for clarity on this issue during the scheduled January 26th meeting and define a agreed handover state for the project. 

Thus, prior to this meeting, development efforts were split between the creation of a prototype system (which implemented a basic content-based filtering model) and on the long-term solution (with multiple recommenders) to the project. The prototype system was demonstrated during an interim meeting on December 7th, where the technical decisions of the long term solution were discussed at length. Following this meeting, implementation of the system proper commenced. 


\newpage
\subsection{Defining the End Product}
\label{sec:jandefinedstate}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Needs reworking
% NOTE:			Needs referencing
% ################# Comment Log ####################
% ##################################################

As we discuss in the previous sections, the decision to define an exact final handover state for the system was deferred until the end of the third development sprint. During our January 26th progress meeting, the team pressed the customer for clarity on how they envisioned the end product. 

It became clear that the customer wished to view the project as a "proof-of-concept" demonstration, with their intended use being to assess the worth of creating a similar system for use with their existing portal. Additionally, they wished to learn from our work, as both developers had little experience in the field of machine learning. The business use of our system would be as a prototype to justify the development resources required to develop their own solution.

With the final handover state of the system now clarified, the team decided that a redesign of the front end of the application was necessary. We noted while giving a demonstration of the software to a non-technical member of the ResDiary team, that the system was not properly communicating the recommendations being made. It was unclear to a non-technical user how the system operated and whether or not the results it produced were sensible. Given it was confirmed that the primary audience of our software will likely be non-technical users (being given a demonstration), there was urgency to produce a more intuitive, friendly front end. 

The following requirements were discovered and added to the project, with the aim of producing a front end redesign which visually demonstrated that the system was producing accurate predictions:

Functional
\begin{itemize}
\item The front end display should display recommendations for a random pool of users to simulate typical use of the system.
\end{itemize}

Nonfunctional
\begin{itemize}
\item The front end be designed such that it is aesthetically clear that the recommendations made are sensible and accurate.
\end{itemize}

%Ensure a reference is provided to feature removal
We also elected in the aftermath of the meeting to drop the proposed nonfunctional requirements of implementing recommendations for new users. A more detailed account into and justification of this decision can be found in Section 3.

\subsection{Delivered Software}
\label{sec:finsoftware}
% ##################################################
% LAST EDIT: 	06/03/17	Joseph
% ################# Comment Log ####################
% ##################################################

% Information on the final software that was delivered to the customer.
In Section \ref{sec:ourinitobjectives} we discuss the specifics of Netflix Recommendations and the Netflix Prize competition so we need to make sure to tie this, the influence and similarity between that system and our final output. 

Additionally we need to demonstrate that the research conducted was RELEVANT.

This section can only be written after the software is in its final handover state.
\newpage


%==============================================================================
\section{Alice}
\label{sec:alice}

This is a example of how to include an image from the figures directory.

\input{figures/alice}

This is an example of how to reference an inlcuded figure (see Figure \ref{fig:alice}).


%==============================================================================
\section{Reflections}
\label{sec:reflections}
% ##################################################
% LAST EDIT: 	14/03/17	Joseph
% NOTE:	Currently misc. thoughts / notes
% ################# Comment Log ####################
% ##################################################

% Several sections that reflect on your experiences during the team project. Each section should discuss one theme, characterised by incidents or events that occurred during the team course of the project from which you learned (approximately 12-15 pages).

% Currently I see a potential layout of Section 3 as follows:

% Technical lead in - summary of technical section to tie detailed technical retrospectives with requirements engineering and testing (requirements engineering is the one to cut / shorten if space needed)

% Technical Reflection: Python - a technical reflection on the choice of Python as the development language

% Technical Reflection: Models & System Design - a technical reflection on the choice of models and how we used them in the creation of our own system design system (if this runs long split into reflection on models and reflection on system design)  

% Technical Reflection: Spark - a technical reflection on the decison to use Spark

% Agile / Technical Reflection: Requirements Engineering - a reflection on the requirements engineering process which the team performed well and made the right choices but tease potential improvements which could have occurred

% Technical Reflection: Testing - a reflection on the testing process with a general summary and discussion of the procedure used with some suggestions for improvements

% ??? We could also talk about prototyping here as a technical development practice and using one front end display as a throaway but space looks tight
% Probably use the protype throwaway stuff throughout and conclude saying how encouraging it in development was a beneficial practice (then again maybe that is more suitable than the requirements engineering reflection - shorten that in favour of prototyping reflection section?)

% Scrum lead in - summary of the Scrum and method reflection points as this is the remaining focus of section 3 and setup the idea that the team used Scrum structure with additional practices and initially developer anarchy before transferring over to structure

% Agile Reflection: Team Organisation - reflection on how the team initially started with anarchy and how the transision over to role based sports model improved development and how the team drew from the knowledge of anarchy to better structure the team at this stage

% Agile Reflection: Communication Breakdown - reflection on how communication was identified as being poor (much like the team structure) then proceeded to be improved slightly before becoming worse then improving slightly again

% Agile Reflection: Code Reviews - reflect on another retrospective point of lack of branching and code reviews and the problems it brought 

% Agile Reflection: Pair Programming - reflect on the few times this was conducted and how it was a beneficial experience that should have been done more often

% Agile Reflection: Dropped Features - reflect briefly on the dropped features but where possible reference away (cost estimation, lack of communication - reference away) and touch mainly on how scope creep and things like that at the start of the project meant the team thought they could achieve more than they did. I imagine the reference away is a simple sentence of two along the lines of 'Some of the most common reasons for feature dropping in industry include X, Y, Z as discussed here (reference). While some of these contributed to the dropping of proposed features (give examples of which explicitly) such as dropping of feature A because of poor cost estimation as discussed here...' the primary reason for dropping of features in our project was scope creep, etc.

% Agile Reflection: Cost Estimation - reflect on the lack of cost estimation and how it contributed partly to the team organisation needed to be reshuffled as parts of the system were avoided how it didn't effect the initial work on the system rather towards the end meant for proposed features needing to be dropped as not enough time was left for their development. Not so much that the priorities were wrong in this regard rather 

% NOTE: Scurm vs. XP - I think this should be best moved to a paragraph of the conclusion as it was not really an 'incident' or 'event' as much as a reflection on if we used the correct methods. Putting it in the conclusion might better suit it.   


\subsection{REFLECTION POINT - Technical Overview Section}
\label{sec:techoverviewreflection}
% ##################################################
% LAST EDIT:  18/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% Development Langauges, Models and Spark being 3 sub-sub-categories within this encompassing category.

% Reference general importance of design decisions here
% Reference specific sub-sub-category when applicable

% If we tie in testing and requirements engineering here the remaining reflections are less technical and
% more agile reflections
% ##################################################

% This section should be a mainly postive reflection of the technical choices of the project.

% The occasional limitation can be mentioned in the passing such as the use of Python scaring the customer off integration (theory) 
% and the drawbacks of the collab not allowing for training based on only new data (this if anything is a requirements engineering failure
% that could have been picked up earlier but customer did not consider until after seeing operation of prototype and use of data in its creation)
% Spark was fine. I have no gripes about using Spark.

1. Talk about why the technical choices are significant development points in the software development process.
2. Talk about how preemptive commitment too early is bad and should be avoided - reference case study - saying team used this as an warning. Use this as reference throw over to requirements engineering reflection point. 
3. Introduce the three major technical decisions of our project
4. Tie in testing and use as a reference throw over

Preemptive commitment to particular design choices too early in the software development cycle leaves a software project at high risk of failure (reference a case study where an incorrect design decision lead to failure - lecture 1 / 3 recommended reading?). Summary of how this system failed in relation to incorrect design choice. 

Say the team used this as a warning for the major design decisions - Development language, Models, Spark - that were involved with our project which are detailed below.

State how the technical choices do not occur in isolation rather they are heavily work with the requirements gathering stage (reference lead in)

Additionally discuss how they are related to the testing of the system (reference lead in) 

However the technical choices of a software project are not made in isolation rather they are heavily influenced by the requirements engineering process of the 

\begin{itemize}
\item Demonstrate that the research conducted was relevant
\end{itemize}


\subsection{REFLECTION POINT - Python}
\label{sec:pyreflection}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

Misc Points:
\begin{itemize}
\item What alternatives did we consider - C Sharp / Scala
\item What were the benefits of using it - already familiar / libraries / industry standard
\item The choice of Python is mentioned in a retrospective as the choice was slow and not well discussed and we just jumped into it - how did we ensure this did not occur with other major technical decisions
\item Did Python influence other later choices - Spark, etc.
\item What were the limitations of using Python
\item Was using Python the correct choice in the long term 
\item Reference papers and libarires to justify why Python 
\item Demonstrate that the research conducted was relevant
\item Was Python the correct choice - research conducted proved Python and C\# integration wouldn't be an issue. However as the customer lacked Python knowledge it probably deterred them from wishing to integrate our system into their existing one. Had the system been created in C\# then perhaps this would have been different. Perhaps this should have been better discussed with the customer in the initial stages of the project.
\item Python chosen as development language as majority of the team have at least two years development experience with it minimum
\item Python industry standard for machine learning projects and thus has a lot of pre-existing libraries the team could utilise during development
\end{itemize}


\subsection{REFLECTION POINT - Models}
\label{sec:modelreflection}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

Misc Points:
\begin{itemize}
\item Tie in the Netflix research (Netflix Prize, etc.) and say how this research influenced our choice of models and system design
\item Explain how the collaborative filter works and WHY it is applicable for our needs
\item Explain how the content based filter works and WHY it is applicable for our needs
\item Reference papers and other models (Netflix) to justify choice
\item What were the limits of the models - customer asked to only retrain on new data but limit of model disallows this - need for specific type of data that is not always present within the data set.
\item Did we choose the right models
\item Did the models impact later decisions
\item Probably suggest some alternative models which could have been explored
\item Demonstrate that the research conducted was relevant
\item Tie in the Netflix competetion and Netflix model as referenced in \ref{sec:initcustobjectives}
\item Knowing the complaints of lacking various fields, columns, data was the model choice actually correct? From the outset it was the more obvious choice but would an alternative have yielded better results working with the data sets we were being given?
\item Jeremy asked about the reusability of our system and the models during the presentation - mention ours is tailored to our specific system and results to improve the accuracy of the results and predictions
\item Mention the system design of having seperate recommenders feed into the system and how these were chosen in relation to that goal and as a result the system designed in the manner that it was.
\end{itemize}


\subsection{REFLECTION POINT - Apache Spark}
\label{sec:sparkreflection}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% Readded after accidental deletion
% ##################################################

\begin{itemize}
\item Team decided the entire team should spend time over Christmas playing around with Apache Spark to ensure common understanding of the system between team members. This may not have been the best use of resource and instead team could have split earlier and the front end developers not bothered playing around with it as they did not end up touching it directly during the development of the project. 
\item Common knowledge was gained though but a more typical front end, back end split in focus may have been beneficial and resulted in an improved front end application sooner.
\item Why was the decision made to use Spark?
\item Did any previous decisions (models / languages / tools) influence our choice of Spark
\item What were the alternatives to using Spark
\item What were the benefits of using it?
\item What were the limitations of using it?
\item Was Spark the right choice?
\item What impact did deciding to use Spark have on the project?
\item Demonstrate that the research conducted was relevant
\item Spark seemed fine for our purposes.
\item Future proposal for system / talk about scalability and benefits of using Spark
\item Quote the numbers Mason! The numbers! (You know the ones Eduard likes to mention)
\end{itemize}


\subsection{REFLECTION POINT - Requirements Engineering}
\label{sec:teamstructure}
% ##################################################
% LAST EDIT:  20/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% - References the cost estimation reflection point as an improvement - tie those two together
% - References scenarios which flows to testing via test scenarios / acceptance testing - ties those two together
% Reference back in subsequent reflection points to reduce lead in repetition 
% ##################################################

% Perhaps tie in the requirements risks and perhaps suggest methods of dealing with such risks via papers

% Basically we've reflected on the technical choices now why was it important that the requirements were engineering properly to better inform the technical choices and what could have been done to do this process even better

From the outset of the project the team were aware of the need to properly capture the requirements of the project. It is widely documented that two of the primary reasons for software failure is due to building the wrong system and building the system incorrectly (said in lecture 3 - get academic proof) both of which were major threats to the development of our project. The team was mindful of how easily building an incorrect system, one not based off similarity between users, or selection of the incorrect machine learning model and subsequent project failure could occur in our project. 

Adhering to the advice of avoiding early commitment to a particular design solution during the requirements elicitation process as is discussed in Section (reference case study reflection at technical overview point) the team left the decision regarding the specific models and tool choice until after this phase was conducted. Although the requirements would evolve as the project developed, as is to be expected, the team felt with the correct initial system goals established the team could easily justify decision designs in relation to the key goals of the system. Such technical decisions, specifically the choice of development language, machine learning models and clustered computing framework, are discussed in Sections (reference all three technical reflections) respectively. 

Knowing the significance of the requirements engineering process for the sucessful development of the project, the team dedicated the first milestone to ensuring the proposed system to be built was correct. This occurred in parallel with technical research into similar systems and their creation (reference Netflix research from section 2). To ensure the team captured all functionality of the system the team, having conducted the initial customer interview, prepared a requirements specification document which was later refined through customer discussions (reference section 2 requirements section). 

Within this document the team elected to use the user stories method of requirements specification in order to create an all encompassing set of stories which reflected the proposed features and functionality of the system. As the recommendations are made to ResDiary customers the team felt user stories provided a good a boundary artifact between the proposed users, customers and developers (taken from PSD lecture 15 key point) and that user stories were a natural choice opposed to alternative specification techniques such as use case diagrams because… 
% Try to sell the idea that user stories are the natural choice for our project as user stories are written from the customer perspective and the recommendations are being made to the end customers

Although some modifications were necessary, as is to be expected, the team found that proposed the user stories modelled the customer requirements with a good level of accuracy (reference section 2 refinements after initial meeting). In addition to this the additional proposed features, generating recommendations for new users and the ability to recommend previously visted restraunts, that the team suggested were recieved with good feedback by the customer. They believed such features tackled aspects of the problem they themselves had not yet considered and felt we had a good understanding of the system. 

% Establish that task estimation was not properly conducted then reference away to specific reflection into that topic
One shortcoming of the use of stories however was the measure of priority attached to each user stories and the subsequent task breakdown by association. The team did not conduct a formal task estimation procedure beyond the breakdown of the user stories into smaller, more general tasks. This was in part due to the lack of technical knowledge into the subject area from the team at this stage in development though the team should have conducted proper task estimation to assist with project planning and management as is discussed here (reference planning and cost estimation reflection point). 

% Transision into this better and potentially expand on
Another area of improvement in the requirement gathering process would have been the inclusion of use scenarios in the “Given, When, Then” format. This is a natural progression of user stories as it expands upon an individual story to provide an example of it in action. Such scenarios could then be utilised to allow for further refinement discussions to occur with the customer in order to better establish conditions for system acceptance which would improve the acceptance tests of the system and allow for scenario testing to be conducted on our system. A discussion regarding such tests and other methods of improvements is discussed in Section (reference testing)  

% Tidy up the ending better - more postive - team did well in this regard and so should end on positive note
Although the aforementioned could have utilised to improve the team's cost estimation and test process for the project, the team established a good understanding of the customer's vision and corresponding system requirements. This ultimately showed during the various customer demonstrations where by second to last meeting they encouraged to the team to follow where we saw the development of the system going as they were already impressed and pleased with the results. This level of confidence placed in the team we feel showed we had a good initial grasp of the system and thus were able to deliver and take steer the project in the direction we saw it heading towards the later stages of the project. 


\subsection{REFLECTION POINT - Testing and Continuous Integration}
\label{testing}
% ##################################################
% LAST EDIT:  25/03/17  Dom
% NOTE:       TODO
% ################# Comment Log ####################
% ##################################################

% Importance of Testing
Testing is an important aspect of any large-scale software project.
Testing helps assert the quality of the software by ensuring that the essential requirements of the system are met.
Detecting and fixing faults early on reduces the cost of fixing those faults in the future.
Testing helps ensure the software is reliable and does not break under non-standard scenarios, such as when fed malformed input.

% Testing Strategy Considerations
% Why was testing important for this project?
Tests were useful for our project as they helped ensure a consistent interface among classes and functions. The test suite aided in minimising the disruption caused by rapid, concurrent changes to the various project components.
Although no strict testing model was enforced during development, the team agreed that the general testing principles of Extreme Programming would be applied during the project.
% Would a TDD test strategy have been suitable? 
% 	A test-driven development strategy would not have been sufficient due to the project being of R\&D nature. The project structure, class definitios and method signatures changed significantly throught the project - a TDD approach would have most likely caused continuous test case rewritting, slowing the entire project down.

% Actual Testing
% When did the testing start in dev cycle?
%	During the later part of the project lifetime
% Why was it late?
%	Due to the experimental nature of the project, early tests would have most likely been rewritten
% There was an overlap between testing and evaluaton
For our project the team decided to have one developer dedicated to the task of testing the system. % Possibly reference this as an industry practice and talk about why the team thought it would be suitable to use this setup for the project. Why it fell in line with our role based sports model from team structure reflection point.
Initially the testing comprised of the creation of a suite of unit tests to ensure that each alteration to the source code did not break the execution / build of the system.
Due to the concurrent development of multiple components of the system, the test suite was helpful in signaling issues early on when expected functionality was not performant, or an expected interface was broken. In particular, concurrent work on multiple recommenders often caused issues when recommendations were merged into the System recommender. These issues were caught and signaled by the test suite, enabling team members to patch broken builds in an efficent manner, allowing the development process to continue smothly.
%Initially it was if the broken builid was reported that the team corrected it immediately - this slacked off a little later in the development cycle but it was still done to a high standard / fast pace. (Quote figures from Jenkins reports in relation to response time as evidence (if they back up this claim) with relation to industy / academic response rate recommendations)

% Integration testing
Integration testing was performed by running the System recommender in conjunction with other recommenders.

% Regresion testing
After integrating the System recommender with other units of code, unit tests served as regression tests for ensuring that existing functionalitydid not fall apart after using the system as a whole.

% Continuous integration
The test suite for the project was set up to run on Jenkins, a continuous integration environment. Automatic test cases ran after each commit to the source code. In case of failure, the team would be instantly notified of a broken build. This enabled early awareness of issues, allowing the team to patch up detected bugs before proceeding to add new features.
Jenkins was also configured to provided coverage reports for the source files, indicating the proportion of the project covered by test cases.

% Coverage
% Reference and talk about why code coverage reports are beneficial in industry and how they can be used to improve testing as we did - reflect that this was a good thing the team did and ultimately helped drive and improve the test process
Coverage is a statistical metric indicating the proportion of source code covered by unit tests. 
The Cobertura extension to Jenkins provided the team with a detailed visual representation of the coverage reports, indicating the percentage of classes, conditionals and lines covered. These reports helped drive the testing process by identifying the portions of the source code which were in need of testing.

% Acceptance tests
% Two ways to spin this:
% 1. Claim that acceptance tests were present:
Acceptance tests were conducted in person with the stakeholders of the project. A presentation displaying several arbitrary diners, their recent bookings and the generated recommendations indicated the sensibility of the engine which met the expected behaviour as defined by user stories.
% 2. Say that there is a lack of acceptance tests
% For example let's say there are no acceptance tests but these were identified a type of testing which would have been beneficial if included. Explain why this would have been beneficial, what extra level of awesome it would have brought to the project and then talk about the steps we could have taken to implemented it into the project.

% Shortcoming and how testing could have been improved
% Explain shortcomings of the testing system used and potential alternatives - one I can recall being that some code was commit which passed tests but broke some functionality of the system. Part of this was due to having a tester who obviously couldn't write tests for code that had just been commit but also may have been due to system not being tested in that regard or something.
A notable shortcoming of the testing was that tests were not written under any particular strategy. This lead to the discovery of several modules missing tests cases, and some tests using untested modules. Following a stricter test plan would have led to more systematic test development, allowing to uncover the beforementioned problems earlier. Mutation testing is another benefit that could have been leveraged by inspecting the test cases themselves and whether they are able to detect edge-cases in the source code.

Performance tests could have been a useful addition to the test suite, however it was difficult to perform such tests due to the project's direct dependency on Spark. The potential speed of computing recommendations was maximised by tweaking the configuration for Spark to use multiple cores. Stress tests would have also been beneficial in order to inspect the behaviour of the engine when processing overly-large files.

A stronger emphasis on acceptance testing would have benefited the team in assuring that the project meets the expectations. Although there were considerations on testing the front-end portion of the project, it was agreed that such tests were not essential for the presentation of the recommendations.

%
% Harsh questions that are partially answered
%
% Are there test strategies specifically for machine learning projects which could have been followed?
% 	Yes, I believe this goes back to evaluating and calculating mean squared error, this is what Paulus and Edward did.
% Could we have used test scenarios with and determined the levels of outcomes are acceptable for each scenario ?
% 	Determining 'levels of outcomes' is hard, not sure about this
% Could we have set objective acceptance criteria and established the amount of error you and your users are willing to accept ?
% 	Yes, setting acceptance criteria from the user stories would have been useful, but establishing the amount of error users are willing to accept is hard due to qualitative results from the engine.
% Should our testing have better utilised statisical measures in relation to the system accuracy?
%	Yes, the statistical part was tricky, that's why most testing resided withing unit testing.
% Could the testing have provided internal feedback on the efforts of the application. First, evaluate the application according to the acceptance criteria. Second, be prepared to support those assertions in statistical terms; for example, be 95 percent confident that the application will produce an answer within a given range. Last, have a high-level understanding of the underpinnings of the application, so that any deficiencies might be able to be ascribed to a particular application component.



\subsection{REFLECTION POINT - Scrum Lead In}
\label{sec:teamstructure}
% ##################################################
% LAST EDIT:  21/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% Ending is real clunky but I like the idea of a lead in general reflection via references to the Scrum
% ##################################################


% !!!!!!!!!!!!!!! IMPORTANT NOTE TO SELF !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Scrum reflection story
%
% The way I envision the general reflection for the Scrum method being 
% examine each of our shortcomings in terms of team workflow (task backlog, communication, etc)
% and to possibly suggest Scrum / XP methods / extensions which could have been employed
% to avoid such failures from the team. This can then be used in the final reflection
% point comparing which framework we should have followed more closely. For example 
% following Scrum more closely with daily (very frequent) stand up meetings would have
% avoided the issue of lack of communication of what you are actively working on.
% Additionally Scrum task and priortiy reviews would have handled that issue, etc.
%
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


% Now see this as a general lead in saying we used Scrum, highlight the overall performance and tease the key failures of our use of Scrum. Finish with a tie in to the final reflection point on whether Scrum was the correct practice to use for the project. 

Lead in with a general why Agile is used for large projects such as ours.

As is often a common practice in industry (get a reference backing up claim) the team did not adhere strictly to one specfic agile framework. Instead the Scrum methodology was used as the overarching framework with additional agile practices from alternative methods, such as prototyping and extreme programming, being adopted as the team felt their use necessary and applicable. While this behaviour ensuresd a flexibile production envirnoment and the team found modertate success with the loose methodology it was not without its issues. Primarily this was due to the lack of discipline within the team to hold all of the key Scrum methods, as weekly stand up style meetings were cancelled in favour of a more open source style of development environment, and roles, as the team employed no product owner role and the scrum master was additionally on the development team. 

Ultimately this would come at a cost of the teams ability to collaborate effectively on the project as the lack of stand ups led to communication issues as is discussed in Section (reference communication issue). Additionally the lack of product owner and focused scrum master roles played into some disfunctionality within the team organisation structure as highlighted in Section (reference team structure). By not conducting incomplete work and priority reviews at the each sprint's end the team inevitably saw proposed features be dropped as is discussed in Section (reference dropping features) and examined more thoroughly in Section (reference backlog management). This however may also be a consequence of the lack of formal cost estimation procedures conducted during the project as examined in Section (reference cost estimation) and not the teams approach to the Scrum methodology. Finally the issue of if whether such failures could have been avoided through use of a different agile framework, the Extreme Programming framework, is considered in comparision to following the Scrum methodology more strictly and closely than was conducted by the team in Section (reference stricter Scrum vs XP - final reflection point).


\subsection{REFLECTION POINT - Team Structure}
\label{sec:teamstructure}
% ##################################################
% LAST EDIT:  25/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% REFERENCE: Developer Anarchy - article || paper on it
% REFERENCE: Sports model of team structure - roles
%
% Perhaps tie in the mythical man month refelction to the ending better as well
% ##################################################

% I feel like I have written the words 'component' and 'aspect' a lot in this section

% Flow seems rough but the idea is that pure anarchy failed - role based system was adopted and here is why - reflect on why the role based system worked well

% Reflect on the transision from Anarchy to a sports model and how it improved the development efficency - improved communication / workflow / etc.

Initially the team elected to use an 'developer anarchy' team structure whereby any team member was free to work on whichever aspect of the system they were currently interested in working on. Despite being an unconventionally structure the team felt confident in our ability to effectively communicate and organise development resources. Anarchy also looked promising due all of the team feeling comfortable to work on both the back and front end functionality of the application as needed. Finally as the proposed system design allowed for concurrent development on different back end recommenders to occur the team believed that the anarchy development style was suited to the project.

During the December 8th retrospective which saw the closure of the first true development milestone, the team was optimistic about the team structure and felt a natural order had fallen into place. The team felt, however, that the organisation and communication could be improved as open communication regarding what developers where actively working on and opinions shared on completed work was absent. (This should have been a sign for code reviews). In addition it was highlighted that task allocation did not actively reflect what developers were actively working on and the team felt this too was adversely affecting the development efforts. Although measures were taken to refectify such behaviors, as is discussed in Section (LINK COMMUNICATION / TASK BACKLOG REFELCTION), at the next retrospective on January 26th it was highlighted that the same issues had occurred once more. Furthermore some team members began to feel underutilised and it was noted that components of the system, the front end, testing and content based recommender, had not seen as much attention as required. To combat this the decision was made to adopt the role based, sports model, of development structure as the team split into two separate development subteams, one to continuing building the recommendation engine and one to construct an improved front end display of the application. The team based this model off ... (reference sports + role model advice which the team followed) and chosen due to its prevalent use in industry (reference stats on this).

Although the roles would alter as development progressed as can be expected from adoption of this model (reference source) the team explicitly assigned one developer to lead development of each of the under development aspects of the system, the creation of the content based recommender, the design and development of the display application and the managing and creation of system testing, with the remaining developers left to lead the development of the existing components, documentation and research into future development work for the system. 

% Say why this model was used - Mythical Man Month / too many cooks in the kitchen - no point of us all trying to work on the ALS system at the same time (with or without branches)
The inspiration of the model of subdividing the team and further subdiving the recommendation engine components was in part due to the forewarning presented in The Mythical Man-Month text (reference). The focus of this text is to provide through case studies a warning against the assumption that adding more developers to a project will in turn speed up the development time of the project and so the team used this advice when setting up our organisational structure. Although the team were not behind schedule as is the general theme of the text, the lesson drawn by the team was the message of employing too many developers who all attempt to work on the same aspect of a system and how this subsequently delays and affects the end product. In addition to the structure subdivision of developers to adhere to this advice the general philosophy was established within the team to avoid "Too many chefs in the kitchen" and thus for developers to be mindful of if they should transision to work on another aspect that was not their primary focus of development. An incident of this which occurred early on in the new development structure was that it was originally proposed for the lead front end developer to assist with the creation of the content based recommender. However realising that this proposed development structure might in fact compromise the initial work of this component and thus delay its creation it was decided retract this role from the developer and refocus their efforts entirely on the display application and documentation of the system. % If you wish to quote to the book directly please use the line: "The bearing of a child takes nine months, no matter how many women are assigned. Many software tasks have this characteristic because of the sequential nature of debugging."

Embarcement of this model saw the productivity of the team vastly increase, partly due to the knowledge gained through working on the project for several months, primarily due to each major component of the system having a developer whose priority it was to lead development. 
% This is clunky but try to get across that roles created sub-experts within the team allowing other developers to know who to ask if an unfamilar part of the system was giving them trouble - Dom turned to Paulius for assistance in setting up tests for unfamiliar aspects, etc.
% Get across the idea that this project wasn't was one of the more complex projects from an implementation standpoint and so this system established a network of experts regarding the different aspects of the system. 
% After change to role system reflect on improvement to development (positive reflections)
While the team still embraced the anarchy philosophy of allowing developers to aid development of different components as desired, having lead section developers established expertise within the team of the various system components. This allowed created a communication loop where developers unfamilar with one aspect of the system knew exactly who to ask their quieries regarding the specifics of the implementation. This was extremely beneficial for the testing development as the lead system tester would often have a query regarding testing one specific aspect of the system and could get a rapid response through asking the lead feature developer about the specific thus reducing the time required to implement the test case which in turn improve the test developers efficeny. Additionally this system improved the feature specific testing as the lead developer fo the component could provide feedback to the tester regarding how to further improve and developer particular tests in order to better verify and test the system.   

% End with what the team learned - saw the dangers of too many developers attempting to work on same aspect and avoided it / how for more complex projects structure was needed and pure anarchy would not suffice.
Through experimentation of the development structure the team eventually found a system which they were comfortable with which resulted in development occurring at a steady pace. This occurred when the distinct, over-arching 'recommendation system' and 'display application' subteams were established and lead developer roles taken up regarding specific subcomponents of those larger topics. In part this decision to subdivide was a natural process as the first few months of 'developer anarchy' allowed the team to experiment with different sections of the development and gave developers the freedom to work on whatever component they believed to be the most important and interesting. Although not a traditional 'Scrum structure' the team found this initial approach to be beneficial when the time came to subdive into teams as the initial developer freedom saw some team members gravitate towards and away from some aspects of the development based off the past experience working with that particular component during the initial stages of the development. As such the team believes that the organisational transition from complete anarchy to a subdivision structure was a natural evolution as developers found the roles they enjoyed and believed they were of most use to the overall development of the project. Although the approach could have been taken to subdivide earlier or from the outset of the project, the team enjoyed the freedom to experiment during the initial stages of the project and view it as having a postive impact towards each developer's initial understanding of the system and how they might best be of use to a successful development process.
    

\subsection{REFLECTION POINT - Communication Breakdown \& Task Backlog}
\label{sec:communicationbreakdown}
% ##################################################
% LAST EDIT:  16/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

An issue highlighted throughout the conducted retrospectives for the project was the issue communication between developers within the team. Although communication did steadily improve over the development period the team prior to entering the final development sprint the team did not believe it to be of the highest possible standard despite some of the highlighted issues being addressed and amended. 

What was found during the first retrospective was that the lack of focused development communication channel resulted in some loss of information between team members. To combat this the decision was made to organise a Slack channel for focused communication regarding the project's development. In addition to this it was also highlighted that only a subset of the developers were actively using the ticket management system (Trac) and so efforts were made to ensure the entirety of the team used the system in a consistent manner. This would see the introduction of some general team wide styling options, such as for commit messages and tickets, to ensure a consistent, clear style was  establish for use within the team. 

What would be seen a subsequent retrospectives follows on from the highlighted issues here of a lack of active communication between what developers were actively working on and a slow response rate to following through on the development work of assigned tickets. 

Considering the former issue what the team found they lacked throughout the entire development process was a lack of frequent communication regarding what team members were actively working on. This would subsequently play a small role in the issues which occurred in the integration of new features as outlined in Section (reference code reviews) though knowing the importance of working coherently in the final development sprint the team did achieve a higher standard towards the end of development which should occurred throughout the entire development process. 

In part the communication issues grew from the decision made to cancel the weekly meetings of the entire team which occurred during the initial stages of development. Partly due to the additional commitments of some team members restricting their availability times the decision was made to reduce the number of full team meetings in favour of an online focused communication system. This system would then reduce the number of full team meetings to preparation meetings for customer meetings, retrospective meetings at the end of each sprint and milestone planning meetings at the start of each sprint. And while some of the introduced methods such as team restructuring as discussed in Section (reference team restucturing section) and the use of pair programming as outlined in Section (reference pair programming section) did see an increase and improvement to the communication between developers the team still felt that active communication regarding development work could have been improved. One potential solution to would have been the use of code reviews as discussed in Section (reference code reviews) though an alternative would have been the following proposition.

- Talk about setting up short stand up style meetings once or twice a week where you just go over what your actively working on.

In hindsight what should have occurred would be to reintroduce the weekly meetings after they were cancelled and the online communication channel seen as being poor until the online channel's use grew to a suitable level to justify cancelling the meetings.       

Misc Notes:
\begin{itemize}
\item Slack was set up and made the dedicated communication channel for project communication.
\item Despite having a Slack communication remained somewhat poor.
\item Decision made to ensure tickets actively represent what feature of the system you are working on.
\item Ticket system improved but commits / development did not occur in a time efficient manner.
\item Sub teams additionally helped communication within front end and back end through team communication as a whole was still somewhat lacking.
\item Specific incident - Edward not providing data sent from customer in a timely manner.
\item Part of team felt agreeing to meet up in person at least once a week to work on project was a waste of time / resources - this had an adverse effect on communication that wasn’t addressed. Instead majority of team met up once a week at scheduled time as some developers strayed through the valley of the shadow of death into the unknown.
\item Perhaps Joseph focusing less on development taking on a purer scrum master of role would have improved the development though it due to this being an academic project that the team felt that not suitable or possible as everyone should have played an active role in development.
\item Talk about the benefits a product owner would have had on the development of our specific project - improved efficiency of tackling task backlog (tasks were avoided from one milestone to the next)
\item (Lecture 7) Perhaps burn down charts per sprints would have been a good idea and would have improved prediction of task completion, backlog management, communication and prioritisation of backlog tasks.
\item Pair programming increase communication and coordination greatly - positive
\item Subteams increased communication a lot as well - postive
\end{itemize}


\subsection{REFLECTION POINT - Code Reviews \& Branching}
\label{sec:codereviewbranch}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% Very, very, rough
% Struggling to explain why it appeared that commits were fine which were in fact broken
% REFERENCE: Good Agile code commit practices
% ##################################################

% Lead in with explanation of why the system design was structured to create the best possible system and in part discouraged branching
From the outset of the project, knowing the importance the system design would have on the development of the project, the proposed design was constructed to achieve high levels of cohesion and low levels coupling within the system. As outlined in Section (reference to system design / models section) at the outset of development the team believed that the individual components, the evaluation system, collaborative and content based filters, in relation to system design where independent enough to allow for development to proceed without the need for development trunks. Rather the team felt adopting a branch heavy menatlity would discourage committing code due to additional time required to handle merge costs and decrease the rate of code refactoring within the project. Although this system of minimising branching did ensure speedy integration of code throughout the duration of the project it was not without its problems during that later stages of the development as are discussed below.

% Explain the problems of this system
As the development of the system progressed and the system complexity increased it was highlighted minorly during the third and significantly during the fourth retrospective was that integration of new code was becoming an issue. Specifically that new code was being added to a particular recommender which would break the system evaluator component in addition to code was often being commit which was unfinished and being refined. Obviously such behaviour is not good Agile practice (reference good Agile practice article) though a potential explanation for this behaviour was due to lack of test strategy in place (reference test reflection point) which would result in the newly added code appearing to function correctly within the existing system, by passing all of the integration tests, whereas in reality it had in fact broken another component of the system. This was due to the integration tests correctly checking the code would generate the recommendations but not that the code was functioning correctly with the evaluation system.

Unfortunately as a result of poor communication between developers (reference communication reflection) this would often lead to another developer's work being deleted in order to fix the broken build which would lead to conflicts within the team. Obviously such behaviour is not acceptable within a development team as was highlighted during the fourth retrospective meeting. To combat this behaviour it was agreed to not delete another developers code without discussing it and justifying it to the developer who wrote the code. Furthermore it was agreed to stop submitting non-functioning code which was still a work in progress. The suggested methods were suggested due to time restrictions placed on the team as the work entered the final development sprint and the proposed solutions did work in the short term. However such practices are neither proper nor are they long term solutions. 
% Explain why the above fixes worked in the short term but are not long term solutions

% Then explain why code reviews are the long term solution to the problem
Instead the standard industry practice of avoiding such internal conflicts is through the use of inspections and code reviews (reference use of code reviews in industry). As one of the key problems for integration was due to the testing suggesting a defect free integration conducting code inspections would have also highlighted defects with the system earlier. As stated in (reference Code Complete course textbook) "the average defect detection rate is only 25 percent for unit testing, 35 percent for function testing, and 45 percent for integration testing. In contrast, the average effectiveness of design and code inspections are 55 and 60 percent" which not only shows that regardless of if the testing was in place that the most effective method of ensuring proper integration would be to conduct the code review process. Although some measure of code review was conducted through the use of pair programming as discussed in Section (reference pair programming) this instead would have been to introduce pre-merge or post-merge code reviews to the project. Adoption of pre-merge reviews in particular would have flagged integration defects and issues earlier and avoided the need to delete code from the master branch in order to fix the build as was highlighted previously when discussing the issues with integration with the evaluation system. The methodology instead would be for new major development work on a particular recommender occurred on a branch. Prior to integration with the master branch a pre-merge code review would be conducted on the branch to be merged between the branch and lead evaluator developers. This would have in theory highlighted merge conflicts and defects in the code earlier and thus avoided the need for one developer to heavily modify anothers in order to amend the disfunctional system. Pre-merge code reviews would also have increased system integration knowledge (wrong wording but how all the componentes integrate and work together) and resulted also in better shared practices within the team, a more consistent code style and reduced the need for some refactoring to occur within the system. 

% End with the team should have done code reviews and wished they had looking back over the development. Although damage control methods mentioned above and pair programming to an extent were used in the short term to rectify issues the code reviews would have solved but that the team's solution was not long term. 
In retrospect the team discovered the benefits and need for code reviews first hand. Although the team effectively coped with the situation and problems which arose from not coducting pre or post merge code reviews such solutions were short term and would not suffice as a long term solution. Ultimately the decision to avoid branching influenced the team's belief for the need to conduct the code review process and as shown while it worked in the initial stages of development as the code base's complexity and interaction between components grew so too did the need for code reviews. Had the team the foresight to realise this then the code review process could have been introduced alongside the introduction of the pair programming process at the start the fourth development milestone.   


\subsection{REFLECTION POINT - Pair Programming}
\label{sec:pairprogramming}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% REFERENCE:  XP Programming Website
% REFERENCE:  Paper on costs and benefits
% REFERENCE:  Agile Allicance 
% Need to tie in references more but the content is largely here
% ##################################################

% Start with why the practice comes recommended
Lead in with a general statement about the benefits of pair programming to a development team (reference). 

% Knowing it comes recommended developers who have not already done it at work on a larger scale and more complex project wished to see how it would translate. How does it translate to actual development beyond the nature of an assignment which is designed to be solveable in a specific way.
Knowing that pair programming is a highly recommended development practice and having some rudimentary experience with the method through the second year JOOSE (yes tie this in better) laboratories some of the developers within the team wished to see how the practice would translate to a much larger and complex project, beyond the artifical designed nature of a academic task within the laboratory setting. Instead the developers wished to see how the practice translated to feature creation and development where the task need not have one particular designed solution in mind.

% Transision into the when, where and why of conducting the process
The decision for some of the developers to partake in this process was made in parallel to the team subdivision as is discussed here (reference). With this structure in place it made logical sense for the two developers wishing to conduct the process be on the same team and so both Josh and Joseph decided to handle the redesign and creation of the display application for the generated recommendations. Initially this started with the two developers meeting to create some GUI mockups for the proposed front end with the start of development work being identified as the best opportunity to conduct the pair programming process. As the team wished follow the development practice prototype of treating the first iteration of the display application as a throwaway prototype and incorporate the feedback and observations made into the redesigned iteration, the fresh start on development work was identified as the best opportunity to conduct the pair programming process. This development work stood out as there was no sense in both developers attempting the work simultaneously rather if used as a pair programming exercise the following benefits would be seen.

% Benefit one it increased coordination and reduced subsequent learning time of the system by the developer who didn't lay the foundations
Firstly pair programming reduces the coordination efforts required within a team since there are N/2 pairs to coordinate instead of N individual developers. As only two developers at this time were developing the display application through use of pair programming both developers knew the entire extent of the development work and the specifics of the system upon completion of the exercise. This allowed for more efficent individual development as both developers had created the foundation of the system and discussed where their individual development efforts would be focused next. 

Secondly as both developers strove for a well designed system foundation the connection between pair programming and better designed solution seemed obvious. As both developers brought differing levels of prior experience, one having more web devlopment experience than the other, saw an increased diffusion in knowledge among the developers which in turn reduced the potential for defects and poor design decisions in the early development work. Having multiple developers also introduced a larger number of potential solutions being proposed for specific problems than a single programmer can suggest. This allowed for discussions regarding which proposition would be the most suited for the long term development of the application and thus also increased the quality of the system's design.  
% Maybe tie in a specific example here but I can't think of one right now 

% Just a quick note on why it was beneficial from a learning perspective
Finally although pair programming should not be viewed as a student-mentor relationship (reference) conducting the pair programming process transfers skills and knowledge between developers by association. Performing this here was of great benefit to the less experienced web developer as he found he picked up on the minute techniques and broader skills used by the more experienced developer. Additionally as he was not faced with an the initial learning curve of attempting to jump in and understand a previously setup system he found he had a greater level of confidence to assist and experiment with development wherever possible.  

% End with its a process that the team wishes they had conducted earlier and more often and possibly suggest some features where it would have proved beneficial - one might be setting up tests for certain aspects of the system. 
Although it was used occasionally for debugging aspects of the display application and recommendation engine, the process as highlighted above for the creation of new features was only conducted once during the development cycle. Having seen the benefits suggested by (reference benefits papers) in real effect the particular developers involved and the team as a whole regretted not conducting the pair programming process more frequently during the development process. Had the team the opportunity to start afresh then pair programming would have been encouraged earlier and more often especially on the development of features such as A
% End with suggestion of where pair programming could have been used


\subsection{REFLECTION POINT - Dropping Features}
\label{sec:droppingreflection}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% Currently a pool of notes
% Two types of feature dropping:
%  1. Dropped due to straying from cutomer vision - new user recommendations
%  2. Dropped due to lack of time / project management / planning - recommendation reasons / system recommender saying contribution states from various other recommenders on the system recommendation / comparision of our system against other methods such as random guessing, etc - mention then fire off to relevant reflection point section 
% ##################################################

% For example, if you found that you had to drop a feature during an iteration, discuss the reasons why the feature had to be dropped. Had you given yourselves too much work? Was the feature harder to implement than you realised? Had you got your priorities wrong? Then consider looking at the literature (see the recommended reading for PSD3) on project planning and estimation. Was your experience typical of a software project? What steps do other developers advocate for improving estimation?

% General lead in regarding that feature dropping occurs for many reasons
The decision to drop a proposed feature from the development schedule of a software project can transpire for a variety of reasons. Examining the reasoning behind such decisions, however, provides an excellent insight and chance for reflection on the development process. Considering the features we decided to drop from development we see an example of both omission due to technical and time constraints in addition development scope creep away from the customer's vision and focus of the project. (reference something that these are two of the primary reasons for feature dropping)

% Talk about recommendation reason as a good feature dropped due to lack of time
% Possibly reference some case studies of similar industy sitations
% Reference away end with may have made development if cost estimation done
An example of the former reason for exclusion was the intended development of providing a metric of reasoning behind the generated recommendations such as stating which recommenders contributed most to the recommendations generated by the system recommender. Despite the team's desire to incorporate such a feature it was ultimately found to be too large a task to implement given the finite amount of time allotted to its creation towards the end of the development process. Instead it was decided that the time should be better spent on refinement of the generated recommendations from the existing system and refactoring the code. Had the team more time to work on the project then the decision would have been made to incorporate such this feature into the system although in retrospect its inclusion may have been possible had the team followed some of the cost estimation techniques described in Section (reference cost estimation techniques).

% Next hit on the features dropped as they were identified as scope creep
% New recommendations found to be search rather than user simularity - dropped as suggested by use when we lacked knowledge / underestimated complexity of the task
% Google maps - research work done but found via observations that the customer need not see this information and so time refocused. Perhaps if recommendation reasoning included then it might have justified the inclusion of this feature.
Within our project the team also made the decision to drop proposed features which were identified as being examples of scope creep introduced by the team. The primary example of this would be the team's initial idea to provide recommendations for new users as well as existing users. This was suggested at the start of the development process by the team and in hindsight was proposed at a time where the team had yet to fully understand the nature of the task, lacked the necessary knowledge to propose extensions and underestimated the complexity of the project. As such this suggestion, while sensible to both the customer and team at the time, is an example gold plating from the development team as additional requirements beyond what was necessary were introduced to the project by the team. Fortunately this feature, which would have taken a significant amount of development resources to construct, was identified as straying too far from the customer's vision of the system. What the team found during some low cost development work and prototyping was that recommendations generated to new users in the proposed manner would be made based off a search or filter system. Such a recommendation strayed from the customer's vision for recommendations to be made based off the simularity between users. Upon discovery of this knowledge the decision was made to drop the proposed feature from development as the resources required for its development were too great as the feature itself strayed too far away from the customer's desire for the system.  

A second example of the team proposing additional work beyond what was necessary within the project was regarding the display application for recommendations and the suggested inclusion of restaurant specific pages containing  additional information on the restaurant and a Google map picture showing where the restaurant was located in relation to the other suggestions and restaurants visited by the user. Once more this was during the initial design phase and was later identified through observations during a customer meeting that it would not be necessary and that merely refining the existing system beyond the list of recommendations with some additional information being provided. As such the decision was made once more to drop this proposed feature from development and refocus the saved resources to refining the existing application with the aforementioned improvements and ensuring the system was properly documented. 

% Lead out with a postive saying the team did well to identify scope creep early on and not waste development resources. If anything proposing all these extra features was due to the creativity within the team and excitement of working on the project
Ultimately although the team was forced to drop a desired feature due to lack of time, the primarly source of feature dropping was due to the introduction of scope creep within the project. In this sense the team performed well because although the additional requirements were suggested for development, largely due to the excitement during the initial stages of development, upon researching the propositions the team were aware enough to realise the features strayed from the customer's primary focus for the system. Consequently the decision was made to drop the features from development and refocus the saved development resources on aspects of the system which did not divert from the customer's intent and thus the team sucessfully avoided wasting development resources on unnecessary development work beyond what initial research work was conducted. 


\subsection{REFLECTION POINT - Cost Estimation}
\label{sec:droppingreflection}
% ##################################################
% LAST EDIT:  20/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

Lead in summaries the other failure points / reflection points that cost estimation caused on the project. For example say it was a significant factor in the dropping of features and reference away. 

\begin{itemize}
\item This comes up a lot and should be its own reflection point
\item Discuss that it was not properly conducted and explain the benefits of employing it
\item Talk potential cost estimation techniques we could have employed (planning poker)
\item Discuss what other developers advocate in this regard and how they could have been incorporated into our project
\end{itemize}


\subsection{REFLECTION POINT - MISC POINTS FROM PSD NOTES}
\label{sec:miscpsd}
% ##################################################
% LAST EDIT:  16/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

Requirements Engineering:
\begin{itemize}
\item (Lecture 13) Requirements gathering is an ongoing iterative process that runs concurrently alongside requirements analysis and capture - our project saw this in real effect due to the changing nature of the requirements of our project.
\item (Lecture 14) Requirements engineering is an iterative process of elicitation, capture and validation - talk about how we did this to ensure we were gathering the correct requirements.
\item (Lecture 3) Causes of software project failing - building system for wrong reason, building the wrong system, building the system wrong. We could tie in the dropped new user recommendation to a proposed goal which was later determined to be a requirement which would be built for the wrong reason. As such the feature was dropped to avoid building an incorrect system.
\item (Lecture 13) Cultural differences between engineers and customers - although the developers were technical they don’t know anything regarding machine learning or the development of a system such as ours - Requirements Risk
\item (Lecture 13) Vague requirements specification of end state of system / customer uncertainty regarding the final state of the system - Requirements Risk
\item (Lecture 13) A means of investigating poorly understood requirements (prototyping) - Managing Requirements Risk - perhaps we could have prototyped both a front end display and an integration method / discussed this with the customer earlier. This would have defined a determined end state of the system prior to January which would have allowed for an earlier split in development focus and resulted in either integration or improved front end. Granted one must also consider that technical decisions were still ongoing at this time.
\item (Lecture 13) Requirements evolution - occurred when we discovered potential features which were ultimately dropped (new user recommendations)
\item (Lecture 14) Avoid early commitments to particular design solutions during requirements elicitation
\end{itemize}

Code Reviews:
\begin{itemize}
\item The system was designed such that branching was unnecessary for the project. Branching was somewhat discouraged throughout the project in order to reduce merge costs / time. Whether the time saved outweighs the time spent fixing and altering other people’s code remains to be seen.
\item Lack of code reviews meant that the code often had inconsistent styling.
\item Lack of code reviews meant a significant portion of time was spent fixing or altering other people's code to work with parts of the system they did not realise they had broken.
\item Lack of code reviews meant code which was WIP was deleted prior to it being fully implemented into the system - again lack of branching issue somewhat.
\item Suggested at the first retrospective but ended up avoiding. Would have reduced a number of problems with development cycle but you can't be perfect.
\item Highlighted in retrospective 3 with the code integration being highlighted.
\item Highlighted even more in retrospective 4 with code integration really being highlighted.
\item Reference potential methods or strategies for code reviews which could have integrated into the development.
\item Reference how other and often professional developers recommend doing code reviews.
\item Mention that pair programming was conducted and the benefits of doing it. Mention it should have been conducted more frequently, reference that it was beneficial when suggesting if XP was potentially better than Scrum.
\item Code reviews might have improved development efficency as less time spent refactoring and fixing broken code. Reduced arguments caused due to deleting other people's code prior to full implementation. Branching also would have fixed this as only get back to master upon passing all tests. This would require testing to have been more efficent as well thus suggesting test strategy should have been utilised to improve test efficency.
\item (Lecture 26) Outline of inspection methods - should probably mention which we should have used in the code reviews.
\item (Lecture 8) Change management and the conflicts caused from developers working in parallel and contributions are made to the master branch which are not fully implemented or break some aspect of the system. In hindsight this probably should have justified a separate branch which would be integrated into the master upon passing all of the tests with a successful build in Jenkins the continuous integration system.
\end{itemize}

Misc:
\begin{itemize}
\item (Lecture 19) Throw-away front end prototype was used and was good as it gave a better understanding of the requirements the front end would require upon it becoming the final state of the system. This knowledge and the discovered failures fed into the redesigned system and so the throw-away prototype was very beneficial to the project. (MINI REFLECTION POINT ?)
\item (Lecture 19) Prototyping is used to reduce risks caused by uncertainty in software projects, not introduce more risk - to some extent this was done for components of the back end system as well.
\item (Lecture 30) Formal specification is a specific thing so probably don't just refer to a specification document as being formal loosely.
\item (Lecture 32) Refactoring is an important process which went on over the course of development.
\end{itemize}


%==============================================================================
\section{Conclusions}
\label{sec:conclusions}
% ##################################################
% LAST EDIT:  
% ################# Comment Log ####################
% ##################################################

% A conclusion that draws general and wider lessons from the case study (approximately 1-2 pages)

Explain the wider lessons that you learned about software engineering,
based on the specific issues discussed in previous sections.  Reflect
on the extent to which these lessons could be generalised to other
types of software project.  Relate the wider lessons to others
reported in case studies in the software engineering literature.

Tie in that although the team introduced scope creep that they were aware enough to kill such proposed features in the crib before too much development time was wasted such development.

I think that you probably tie the protype throwaway stuff in here and say how encouraging it in development was a beneficial practice (then again maybe that is more suitable than the requirements engineering reflection - shorten that in favour of prototyping?)

Conclusion point - pair programming was beneficial and those who conducted in the practice got a lot out of it.

% Moving this to here for now as I beieve a paragraph addressing it here is better suited and flows better
Comparision I see here being made now is should we have stuck with Scrum but follow the practice more closely with stand ups, product owner and scrum master - ensure to explain academic nature of project affecting that one in some regard, extensions to Scrum methods which could have been used to tackle specific problems, etc.

Contrast this against using the XP system for example.

Misc points:
\begin{itemize}
\item Our prototyping was beneficial - gave good understanding of working with the data sets in addition to seeing how and what the front end application would need to convey to non-technical people and people not familiar with the nature of the project. Spin here is to implement more forms of prototyping as this was beneficial and perhaps should have been conducted more. Not Scrum or XP but another framework that could have been adapted in. 
\item Time between meetings served as a good sprint dates - working on smaller iterations may have ensured better communication within the team.
\item Development typically did not change much within a sprint - XP difference here may not have made much of a difference though the dropped feature could have been explored earlier in the development cycle than the 2nd semester.
\item Task priority was a bit of an issue as we didn’t really do proper task estimation - XP would have solved that issue as it forces strict policy and task estimation.
\item Scrum has no engineering practices whereas our project definitely should have. XP would have forced pair programming from the start (rather than sporadic occurrences within sprints), ensured better, more thorough testing from an earlier stage in the project and avoided the whole code review “you deleted all my code you bastard” arguments.
\item User stories are originally from XP 
\item Scenarios are from XP - discussed in requirements engineering reflection point 
\item Instead perhaps it would have been better to adopt additional Scrum extensions of backlog refinement and burn down charts in addition to having more defined roles and stand up meetings.
\item Reference throughout to relevant subsection reflection points tackling each specific issue.
\item Although the team did not conform to the Scrum practice of holding daily, or frequent, stand up meetings and the consequences of this practice are discussed at length in Section (reference lack of stand ups / poor communication).
\item Look into Scrumban and Agilo for Trac - did a light version informally but it would may have improved the process to got all out and use this.
\end{itemize}

%==============================================================================
\bibliographystyle{plain}
\bibliography{dissertation}
\end{document}
