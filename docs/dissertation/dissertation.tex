% This example An LaTeX document showing how to use the l3proj class to
% write your report. Use pdflatex and bibtex to process the file, creating 
% a PDF file as output (there is no need to use dvips when using pdflatex).
% Modified 

% This dissertation was built upon base template provided.

\documentclass{l3proj}

\begin{document}

\title{Team I: ResDiary Restaurant Recommendation System}

\author{Vladimir Bardarski \\
        Paulius Dilkas \\
        Domantas Jurkus \\
        Eduard Kalfov \\
        Josh O'Brien \\
		Joseph O'Hagan}

\date{31st March 2017}

\maketitle

% ##################################################
% LAST EDIT: 	06/03/17	Joseph
% ################# Comment Log ####################
% ##################################################
\begin{abstract}
The abstract shall go here! Here is some things to keep in mind while writing it.
\end{abstract}

\begin{itemize}
\item The abstract is likely the first substantive description of your work read by an examiner. View it as an opportunity to set accurate expectations.
\item The abstract is a summary of the whole thesis. It presents all the major elements of your work in a highly condensed form. (Write it having written the rest of the paper) The paper sets the abstract.
\item It must be capable of substituting for the whole paper when there is insufficient time and space for the full text.
\item Keep it short and snappy. 
\item The primary function of your thesis (and by extension your abstract) is not to tell readers what you did, it is to tell them what you discovered.
\item Approximately the last half of the abstract should be dedicated to summarizing and interpreting your results.
\item The most common error in abstracts is failure to present results.
\end{itemize}

% Comment out this line if you do not wish to give consent for your work to be distributed in electronic format.
% We hereby give consent - spread the knowledge - pending on result of project
\educationalconsent
\newpage

%==============================================================================

% ##################################################
% LAST EDIT: 	06/03/17	Josh
% ################# Comment Log ####################
% ##################################################
\section{Introduction}
\label{sec:intro}
% An introduction, explaining the purpose of the document, a very brief outline of the project and a summary of the structure of the rest of the document (approximately 1-2 pages).

The Professional Software Development (PSD3) course at The University of Glasgow requires students to engage with the practices and methodologies used in modern large-scale software engineering. The purpose of this dissertation is to document the development of the software project created as part of this course by Team I. 

The project was to build, over the course of several months, a recommendation engine for the Glasgow-based company ResDiary.
The main deliverable was a system capable of producing sensible restaurant recommendations for existing ResDiary users; a system that could be integrated into the existing ResDiary platform at a later date. 

Our team consisted of six third-year Computing Science students. Within the group there was a broad range of skills, interests and experience - with two members actively working as software professionals, and another having participated in an internship. For some members, however, this was a first opportunity to interact with a real client. 

In this document we outline, in detail, the entire process: from the initial requirements gathering with our customer, through to final system delivery. 

In section \ref{sec:background} we present the background to the project, the motivations of the customer and how we arrived at the agreed deliverables.

%this will surely be expanded to enumerate each separate section better I would like to discuss in detail the practices, issue-tracking, the team work/team load - Josh etc.

In subsequent sections \ref{sec:alice} through Section \ref{sec:reflections} we explore the challenges we faced through development and the steps we took to resolve them, explore the impact of team dynamics on the outcome and reflect on what we have learned from the experience. We also explain how we applied the good development practices learned in PSD3. In particular we highlight the role of version control, agile development and issue tracking.

\newpage

%==============================================================================

\section{Case Study Background}
\label{sec:background}
% A description of the case study background and context. This should include a description of the project customer (what was the nature of the organisation you were working for), their objectives for the project, and a summary of what was actually achieved. Where appropriate, this section should also make reference to similar related projects in order to make the context clear (approximately 4-5 pages).

\subsection{Customer}
\label{sec:customer}
% ##################################################
% LAST EDIT: 	18/03/17	Josh
% ################# Comment Log ####################
% ##################################################

% The customer organisation and background.

% Here we want answer the question of who are ResDiary and what do they do.
% Additionally answer who played the customer role of ResDiary to us on the project.

% Who are ResDiary?
ResDiary are a Glasgow-based online restaurant reservation service; a commercial organisation providing a comprehensive, easy to use booking and table management platform for use by the hospitality industry. The company provides 24-hour reservation services through both social media and their own booking portal ResDiary.com. Diners can browse restaurants, book tables and place reviews. Restaurants can access tools which let them optimize their yields, manage their reservations and attract new diners. Their global service sees 9.7 million bookings every month, and their platform is used by over 6,500 restaurants across 58 countries. 

ResDiary senior software engineers Adam Connelly and Ian Strachan acted as customer representatives throughout the duration of the development. They helped us understand the company line-of-thought behind the project, in addition to providing useful feedback, answering queries and supplying the team with the anonymised ResDiary booking data we required.


\subsection{Customer Objectives And Rationale}
\label{sec:custobjectives}
% ##################################################
% LAST EDIT: 	23/03/17    Joseph
% NOTE: 		Reference papers on Amazon / Netflix Models / Netflix Prize
% NOTE:         Added more specifics on Netflix Recommendations - make sure to tie in to our final output
%               Need to demonstrate that the research was RELEVANT
% ################# Comment Log ####################
%   Really explain why the project is beneficial to the customer - why would recommendations increase business, etc. - this was question / critique of project motives section of the presentation -- Joseph  
% ##################################################

% The rationale and initial objectives for the project.

% Initial Meeting and the customer's motivation for the project.

The initial customer meeting occurred on October 19th and was led by Ian Strachan. This was our first contact with the customer and served as the customer requirements elicitation meeting. The meeting began with an overview of the ResDairy business \ref{sec:customer}, a discussion of the services they provide and an explanation of their technology stack. The ResDiary daily operation involves gathering large quantities of valuable customer data. This collection of big data, however, is currently unused beyond supporting basic business needs (i.e. retrieving booking records). The developers view this as a significant shortcoming of their system.

As such, therefore, the company is exploring potential ways to exploit this vast quantity of valuable data. The developers had conducted some research into the area, and discovered that none of their competitors currently offer a restaurant recommendation service within their booking platform. Thus, if they were able to develop a system which would make recommendations to users based on their previous dining habits and similarity to other users, they would gain a competitive edge. It would also help increase restaurant discovery on their platform, which is beneficial to both restaurants and potential clientele. 

The inspiration for the idea stems from the similar system provided by online services such as Amazon and Netflix, which push recommended products and films respectively to their users. The Netflix model, in particular, was the closest reference point for the system they wished to develop. A parallel between making recommendations based on a user's film history and their similarity to other users, and a similar recommendation engine using ResDiary's dining history is easy to see. As a starting point for our own research, they suggested looking into the Netflix Prize - a competition held by Netflix starting in 2006 challenging participants to better their own recommendation algorithm. 

The goal of the algorithm was to accurately predict a user's rating of a film based solely on previous user ratings and no additional information about either the users or films. A set of training data (a subset of Netflix's real user data) with half a million user ratings was provided to participants, with the algorithm using this data to predict user ratings for a disjoint subset of the user data. No information other than user ID, film ID and date of rating was provided. Our Resdiary project followed a similar structure. ResDiary's users, as with Netflix's, leave review scores ranging from 1 to 5. We were given a subset of their user data which we split into further subsets for training and for evaluation. The research provided an excellent springboard from which to launch our own collaborative filtering model. With such a strong similarity between the requirements of our system and theirs, it was a natural choice.

% Maybe move the Netflix stuff to the choice of models to save on space in this section -- Joseph 27/03

We also spent time discussing what the customer viewed as the end state of the system - whether it would be integreated into the existing ResDiary portal or whether the output would suffice as a proof-of-concept prototype. They were initially undecided in this regard, partially due to an internal transition in their own development frameworks, and thus suggested our initial aim should be to focus on the creation of the recommendation engine. The decision regarding the final state of the project ultimately would not be made until midway through the development cycle when the customer decided to view the project as simply a proof-of-concept. Nonetheless, at all points during development, due consideration was given to the future integration of our system with ResDiary. 


\subsection{Project Scoping}
\label{sec:ourinitobjectives}
% ##################################################
% LAST EDIT:  18/03/17  Josh
% NOTE:         JOSH: Expanded on importance of requirements.
% NOTE:         References: importance of requirements gathering, cost of making corrections 
% ################# Comment Log ####################
% If required (page count) maybe cut down requirements engineering and incorporating customer 
% feedback in reflection point - we did it pretty well though so there wasn't much to improve
% ##################################################

The risks and costs associated with a project of this nature demand thorough background investigation and cogent planning before development proper commences. The cost of correcting errors grows enormously in the latter stages of a software project.

Our first major task was to formalise our discussions with the client and produce a requirements specification to serve as a project proposal document. The goal was to have a clear outline of the scope of the project and a set of deliverables to present to the client at the next meeting on November 16th. Our requirements gathering occurred in tandem with conducting the necessary initial background research on machine learning and recommendation systems. 

The proposal document included an array of requirements that the team agreed upon, based on our interpretation of the customer's initial project pitch. It was important that our requirements were reasonably comprehensive and realistic, but we accepted that they would be continually revised and refined as the project developed. 

\subsubsection{Initial functional requirements:}
\begin{itemize}
\item The recommendation engine must accurately suggest restaurants based on the users' dining history and similarity to other users with similar eating preferences.
\item Recommended restaurants should be in close proximity to where the user typically eats or the geographical location of where they are currently searching.
\item The recommendation engine may recommend restaurants that  the user has previously visited should the user allow this option.
\end{itemize}

\subsubsection{Initial nonfunctional requirements:}
\begin{itemize}
\item The engine should be written to allow for easy integration into the existing ResDiary system.
\item The system should give a response within one second after receiving the request (provided data is stored locally).
\item New users should be presented an optional quick questionnaire to gather initial data.
\item User and restaurant locations should be interpreted using coordinates rather than city name as those are of arbitrary precision within the dataset.
\end{itemize}

To help us understand the actual scenarios in which the system might be used, we prepared a set of user stories (ranked by priority). They provided a quick, intuitive way to ensure we had covered all the conceivable use cases the customer may require. We also prepared a high-level system UML diagram and a step-by-step work-flow of how the system would generate the actual recommendations. Due to the customer's ambiguity regarding the final state of the system, the endpoint was left intentionally vague to allow for flexibility. Instead the emphasis was to build and produce the most accurate recommendation for a given user. 


\subsection{Refinement of Requirements}
\label{sec:custrefineinitobj}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Needs reworking
% NOTE:			Needs referencing
% ################# Comment Log ####################
% If required (page count) maybe cut down requirements engineering and incorporating customer feedback in reflection point
% ##################################################

% The suggested alternative was to use a nightly build system which the team would utilise in the final version of the system (!R! REFERENCE TO SPARK REFLECTION !R!).

At the November 16th meeting we presented and discussed our project proposal with the customer.

They felt we had a good understanding of their vision. They broadly agreed with the proposed requirements and could envision how our high level system would operate (and potentially integrate into their existing one). We briefly explained that there were two major models for building recommendation systems: collaborative-based filtering and content-based filtering. The high level system architecture accounts for this by allowing multiple 'recommenders' to each implement a different approach to producing recommendations. These recommendations are then combined and filtered for the final output. The customer expressed strong interest in the potential of "fine tuning" this system, through altering the significance placed on individual recommenders. 

% Probably include the UML diagram (the one used in the presentation as well) in here to help explain the system -- Joseph 27/03

There were, of course, areas of concern. Our proposed response rate of one second to respond to a request was queried. They felt that they needed to further clarify the volume of data the system would be expected to work with in a real world deployment. This may put a constraint on our ability to realise that performance. We discussed the alternative of using a nightly build system, as this how they expected the system would operate in a real world setting. In addition, they recommended developing a lightweight front-end application to display the recommendations. This would be a lightweight app, rather than any actual integration with their system, but they rationalised its throwaway nature by suggesting it would help them better understand our system, assist with demonstrating its functionality and most importantly provide a clear indication it was producing sensible results. 

We made modifications to the specification document to incorporate the customer feedback. In particular, the team felt the need to revise the non-functional requirements of the project. The disputed "one second local response rate" requirement was rescinded and in its place we inserted two new requirements:

\begin{itemize}
\item Provided the data is not stored locally, the system should be set up to allow for nightly updates to the recommendations.
\item Have the ability to “fine tune” the recommendation engine by altering the weighting significance of different components of the recommendation such as distance, price, 
reviews, etc.
\end{itemize}

Furthermore, a soft goal developed within the team to produce a more comprehensive front end application to showcase the recommendation system. While some members felt this justified being included and defined formally within the specification document, the majority instead felt the focus of the project should be on creating the most accurate recommendations. We elected to delay defining an exact end state until the customer clarified exactly what they required. We agreed, eventually, that should clarify not be forthcoming, we would press for clarity on the issue during the scheduled January 26th meeting, and define an agreed handover state for the project. 

While some of the team felt this justified being defined within the specification the majority instead felt the focus of the project should be on creating the most accurate recommendations and delay defining an end state until it was defined by the customer. Should the customer not provide clarity earlier it was decided to press for clarity on this issue during the scheduled January 26th meeting and define a agreed handover state for the project. 

Thus, prior to this meeting, development efforts were split between the creation of a prototype system (which implemented a basic content-based filtering model) and on the long-term solution (with multiple recommenders) to the project. The prototype system was demonstrated during an interim meeting on December 7th, where the technical decisions of the long term solution were discussed at length. Following this meeting, implementation of the system proper commenced. 


\newpage
\subsection{Defining the End Product}
\label{sec:jandefinedstate}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Needs reworking
% NOTE:			Needs referencing
% ################# Comment Log ####################
% ##################################################

As we discuss in the previous sections, the decision to define an exact final handover state for the system was deferred until the end of the third development sprint. During our January 26th progress meeting, the team pressed the customer for clarity on how they envisioned the end product. 

It became clear that the customer wished to view the project as a "proof-of-concept" demonstration, with their intended use being to assess the worth of creating a similar system for use with their existing portal. Additionally, they wished to learn from our work, as both developers had little experience in the field of machine learning. The business use of our system would be as a prototype to justify the development resources required to develop their own solution.

With the final handover state of the system now clarified, the team decided that a redesign of the front end of the application was necessary. We noted while giving a demonstration of the software to a non-technical member of the ResDiary team, that the system was not properly communicating the recommendations being made. It was unclear to a non-technical user how the system operated and whether or not the results it produced were sensible. Given it was confirmed that the primary audience of our software will likely be non-technical users (being given a demonstration), there was urgency to produce a more intuitive, friendly front end. 

The following requirements were discovered and added to the project, with the aim of producing a front end redesign which visually demonstrated that the system was producing accurate predictions:

Functional
\begin{itemize}
\item The front end display should display recommendations for a random pool of users to simulate typical use of the system.
\end{itemize}

Nonfunctional
\begin{itemize}
\item The front end be designed such that it is aesthetically clear that the recommendations made are sensible and accurate.
\end{itemize}

%Ensure a reference is provided to feature removal
We also elected in the aftermath of the meeting to drop the proposed nonfunctional requirements of implementing recommendations for new users. A more detailed account into and justification of this decision can be found in Section 3.

\subsection{Delivered Software}
\label{sec:finsoftware}
% ##################################################
% LAST EDIT: 	06/03/17	Joseph
% ################# Comment Log ####################
% ##################################################

% Information on the final software that was delivered to the customer.

This is a postive brief summary of all that was achieve.

The customer was happy so we are also happy with our creation.

In Section \ref{sec:ourinitobjectives} we discuss the specifics of Netflix Recommendations and the Netflix Prize competition so we need to make sure to tie this, the influence and similarity between that system and our final output. 

Additionally we need to demonstrate that the research conducted was RELEVANT.

Show how the research of the Netflix prize lead us to collab / content / etc. which was used in the final system

Need to hit what we achieved - an implict and explict collaborative filter, content based filters on cuisine type and price point, location filtering, auto configuration and the evaluator system. Mention integration with Spark better than we did in the presentation. This outputed csv files which fed into the display application though it could easily be configured to work with a database. 

Mention some of the future proposals we hit on in the presentation such as the reasoning for recommendations, expanding the collaborative to use more than the limits of the data we worked with and content based recommendations for location.

\newpage


%==============================================================================
\section{Alice}
\label{sec:alice}

This is a example of how to include an image from the figures directory.

\input{figures/alice}

This is an example of how to reference an inlcuded figure (see Figure \ref{fig:alice}).


%==============================================================================
\section{Reflections}
\label{sec:reflections}
% ##################################################
% LAST EDIT: 	14/03/17	Joseph
% NOTE:	Currently misc. thoughts / notes
% ################# Comment Log ####################
% ##################################################

% Several sections that reflect on your experiences during the team project. Each section should discuss one theme, characterised by incidents or events that occurred during the team course of the project from which you learned (approximately 12-15 pages).

% Currently I see a potential layout of Section 3 as follows:

% Technical Reflection: Python - a technical reflection on the choice of Python as the development language

% Technical Reflection: Models & System Design - a technical reflection on the choice of models and how we used them in the creation of our own system design system (if this runs long split into reflection on models and reflection on system design)  

% Technical Reflection: Spark - a technical reflection on the decison to use Spark

% Agile / Technical Reflection: Requirements Engineering - a reflection on the requirements engineering process which the team performed well and made the right choices but tease potential improvements which could have occurred

% Technical Reflection: Testing - a reflection on the testing process with a general summary and discussion of the procedure used with some suggestions for improvements

% Agile Reflection: Team Organisation - reflection on how the team initially started with anarchy and how the transision over to role based sports model improved development and how the team drew from the knowledge of anarchy to better structure the team at this stage

% Agile Reflection: Communication Breakdown - reflection on how communication was identified as being poor (much like the team structure) then proceeded to be improved slightly before becoming worse then improving slightly again

% Agile Reflection: Code Reviews - reflect on another retrospective point of lack of branching and code reviews and the problems it brought 

% Agile Reflection: Pair Programming - reflect on the few times this was conducted and how it was a beneficial experience that should have been done more often

% Agile Reflection: Dropped Features - reflect briefly on the dropped features but where possible reference away (cost estimation, lack of communication - reference away) and touch mainly on how scope creep and things like that at the start of the project meant the team thought they could achieve more than they did. I imagine the reference away is a simple sentence of two along the lines of 'Some of the most common reasons for feature dropping in industry include X, Y, Z as discussed here (reference). While some of these contributed to the dropping of proposed features (give examples of which explicitly) such as dropping of feature A because of poor cost estimation as discussed here...' the primary reason for dropping of features in our project was scope creep, etc.

% Agile Reflection: Cost Estimation - reflect on the lack of cost estimation and how it contributed partly to the team organisation needed to be reshuffled as parts of the system were avoided how it didn't effect the initial work on the system rather towards the end meant for proposed features needing to be dropped as not enough time was left for their development. Not so much that the priorities were wrong in this regard rather 


\subsection{Lead in to reflection points}
\label{sec:techoverviewreflection}
% ##################################################
% LAST EDIT:  27/03/17  Joseph
% NOTE:      
% ################# Comment Log ####################

% Originally I proposed a separate agile and technical one of these
% We don't have the space or time to do that

% It works better to have one lead in to this section anyway - why have to lead ins?

% ##################################################

% Reference off every reflection section in Section 3 and end with a tie in to the conclusion

Throughout the development of the software project the team faced many trials and tribulations. From the early technical choices on which success of the project lay balanced to Agile practices and methods employed for successful development; it was a hell of a ride. 

Despite the successful development achieved by the team (reference Section 2 final state) within any software project there is room from improvements in both the technical decisions and development methodology. From the technical perspective one must consider whether the major decisions, (reference Python, Spark and Models Reflections), where in fact the correct decisions to have made in retrospect. Additionally one might also consider if the system was correctly tested (reference Testing Reflection) for no system is released bug free and testing always improved. 

From the development process and methods used there again is room for improvement, even when following the Agile development practices of the Scrum and Extreme Programming methodologies as the team did. It may be that the team chooses instead to not adhere strictly to such frameworks and instead opt for a looser and more flexible development methodology. What transpires from this approach though is the discovery of some practices which the team regrets having not introduced earlier (reference Pair programming) but also the risk of introducing problems which transpire over time (reference cost estimation and communication). Whereas some problems can be easily addressed upon encounter through the introduction of additional development structure (reference team organisation) others must unfortunately utilise temporary methods to complete development when clear long term solutions clearly exist (reference code reviews). Considering all of this especially of importance when considering why the project was forced to dropped proposed development features (reference dropped features) though the ultimate goal being to grow as a developer and consider the experienced gained from the development process (reference conclusion).


\subsection{REFLECTION POINT - Python vs C\#}
\label{sec:pyreflection}
% ##################################################
% LAST EDIT:  27/03/17  Joseph
% NOTE:       This will do
% ################# Comment Log ####################
% REFERENCE: Accord.NET [1]
% REFERENCE: Section on Spark [2]
% REFERENCE: Python pre-existing libraries [3]
% ##################################################

% ################# References #####################

% ##################################################

One of the key considerations in any software development project is the choice of the technologies used to implement it. We spent much of the first iteration contesting two broad approaches: implementing the system in their own language (C\#) or using our Python alternative.

From an early stage, as we outline in section 2, it was clear the client placed a high priority on integration with their existing system. In other words: with their existing technology stack. ResDiary uses Microsoft's C\# language and the ASP.NET web framework for its backend system. The natural starting point, therefore, was to find a solution within that language ecosystem. 

% [1]
It became clear very quickly that in order to meet the goal of delivering a recommendation system within the time limit, we would be compelled to draw on existing machine learning libraries. It was not practical, nor within the team’s competency to write complex big data algorithms from scratch. The team researched machine learning libraries in C\# and found some promising results - the popular Accord.NET library providing much of the required functionality. 

% [2], [3]
Eventually, however, we agreed on using the Spark machine learning library, using Python. Python is the industry standard for machine learning projects and had a lot of pre-existing libraries the team could utilise during development. Its natural application domain is scripting and data analysis. By contrast, though it does have some suitable libraries, C\# is geared toward web applications. Python also had the advantage of being familiar to the team, with the majority of members having at least two years development experience. By contrast, only one member had significant experience with C\# and the ASP.NET framework.

Of course, the choice of Python begs the question of how we integrate with the customer system. While our research indicated that calling Python scripts from C\# would not be an issue, the client did not have much familiarity with Python and that may have deterred them from wishing to use our system as more than a proof-of-concept ultimately. The choice of language, perhaps, should have been discussed more thoroughly in the initial stages of the project.


\subsection{REFLECTION POINT - Models}
\label{sec:modelreflection}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

% ################# References #####################
% ##################################################


Misc Points:
\begin{itemize}
\item Tie in the Netflix research (Netflix Prize, etc.) and say how this research influenced our choice of models and system design
\item Explain how the collaborative filter works and WHY it is applicable for our needs
\item Explain how the content based filter works and WHY it is applicable for our needs
\item Reference papers and other models (Netflix) to justify choice
\item What were the limits of the models - customer asked to only retrain on new data but limit of model disallows this - need for specific type of data that is not always present within the data set.
\item Did we choose the right models
\item Did the models impact later decisions
\item Probably suggest some alternative models which could have been explored
\item Demonstrate that the research conducted was relevant
\item Tie in the Netflix competetion and Netflix model as referenced in \ref{sec:initcustobjectives}
\item Knowing the complaints of lacking various fields, columns, data was the model choice actually correct? From the outset it was the more obvious choice but would an alternative have yielded better results working with the data sets we were being given?
\item Jeremy asked about the reusability of our system and the models during the presentation - mention ours is tailored to our specific system and results to improve the accuracy of the results and predictions
\item Mention the system design of having seperate recommenders feed into the system and how these were chosen in relation to that goal and as a result the system designed in the manner that it was.
\end{itemize}


\subsection{REFLECTION POINT - Apache Spark}
\label{sec:sparkreflection}
% ##################################################
% LAST EDIT:  15/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% ##################################################

% ################# References #####################
% http://www.infoworld.com/article/3031690/analytics/why-you-should-use-spark-for-machine-learning.html
% ##################################################


\begin{itemize}
\item Team decided the entire team should spend time over Christmas playing around with Apache Spark to ensure common understanding of the system between team members. This may not have been the best use of resource and instead team could have split earlier and the front end developers not bothered playing around with it as they did not end up touching it directly during the development of the project. 
\item Common knowledge was gained though but a more typical front end, back end split in focus may have been beneficial and resulted in an improved front end application sooner.
\item Why was the decision made to use Spark?
\item Did any previous decisions (models / languages / tools) influence our choice of Spark
\item What were the alternatives to using Spark
\item What were the benefits of using it?
\item What were the limitations of using it?
\item Was Spark the right choice?
\item What impact did deciding to use Spark have on the project?
\item Demonstrate that the research conducted was relevant
\item Spark seemed fine for our purposes.
\item Future proposal for system / talk about scalability and benefits of using Spark
\item Quote the numbers Mason! The numbers! (You know the ones Eduard likes to mention)
\item Limited the ability to perform performance tests on the system
\end{itemize}


\subsection{REFLECTION POINT - Testing and Continuous Integration}
\label{testing}
% ##################################################
% LAST EDIT:  26/03/17  Josepg
% NOTE:       Draft
% ################# Comment Log ####################
% There should be more events and incidents from the development in here
% ##################################################

% ################# References #####################
% [1] http://fileadmin.cs.lth.se/cs/education/EDA270/Reports/2009/SvenssonGraden.pdf 

% Test Driven Development - Software Engineering Course Textbook Section 8.2

% Continuous Integration References
% https://www.martinfowler.com/articles/continuousIntegration.html
% http://aosabook.org/en/integration.html
% ##################################################

% -- Importance of Testing --
% Testing is an important aspect of any large-scale software project. Testing helps assert the quality of the software by ensuring that the essential requirements of the system are met. Detecting and fixing faults early on reduces the cost of fixing those faults in the future. Testing helps ensure the software is reliable and does not break under non-standard scenarios, such as when fed malformed input.

% -- Testing Strategy Considerations -- 
% -- Why was testing important for this project? -- 
% Tests were useful for our project as they helped ensure a consistent interface among classes and functions. The test suite aided in minimising the disruption caused by rapid, concurrent changes to the various project components.
% Although no strict testing model was enforced during development, the team agreed that the general testing principles of Extreme Programming would be applied during the project.

% -- Would a TDD test strategy have been suitable? --
% A test-driven development strategy would not have been sufficient due to the project being of R\&D nature. The project structure, class definitios and method signatures changed significantly throught the project - a TDD approach would have most likely caused continuous test case rewritting, slowing the entire project down.

% -- When did the testing start in dev cycle? --
% During the later part of the project lifetime
% -- Why was it late? --
% Due to the experimental nature of the project, early tests would have most likely been rewritten

% The five types of testing to hit on - unit, integration, acceptance, regression, system

% Shortcoming and how testing could have been improved
% Explain shortcomings of the testing system used and potential alternatives - one I can recall being that some code was commit which passed tests but broke some functionality of the system. Part of this was due to having a tester who obviously couldn't write tests for code that had just been commit but also may have been due to system not being tested in that regard or something.


The through testing of any large-scale software project is a vital process which must be conducted. The testing procedure helps validate and verify the built system in addition to assisting with measurement of the quality of the system. Utilisation of testing, through continuous integration or otherwise, allows for the detection of system faults and deficates earlier in the development process which in turn reduces the cost of correcting faults further on in the development. In relation to our project, testing proved useful to ensure consistent interface usage amongst classes and functions. The use of a test suite aided with minimising the disruption induced by rapid, concurrent changes to various project components and deployment via continuous integration environment ensured instant notification of a broken build to all of the development team. 

Knowing the importance of the test process the team made the decision to dedicate the majority of one developer's efforts to the process of testing the system as is outlined in Section (reference team structure). It was at this point where the team felt the introduction of testing to the project would be most beneficial as introduction earlier while the system was still experimental in nature would have resulted in early tests being frequently rewritten. The decision to employ one developer to lead the testing process came from the decision to adopt the role based sports model and so the role of lead test developer felt like a natural role for which one developer should take. 

% [1]
At this time the team discussed whether the test-driven development strategy was applicable to our project. This was eventually decided to not be sufficent due to the research based nature of the system as the project structure, class definitions and method signatures changed significantly throughout the development cycle. Utilising a test-driven development strategy the team believed would most likely have caused continuous test case rewritting thus slowing down the entire project's development. As such rather than follow a strict testing strategy or policy the team instead adopted the five types of testing outlined for the Extreme Programming methodology in Section 2 of the paper (reference - paper with section 2 full of types of testing and maybe expand on this a little).

Initially the testing comprised of the creation of a suite of unit tests to ensure that each alteration to the source code did not break the execution / build of the system.
Due to the concurrent development of multiple components of the system, the test suite was helpful in signaling issues early on when expected functionality was not performant or an expected interface was broken. In particular, the concurrent work on multiple recommenders often caused issues when recommendations were merged into the System recommender. Such issues were caught and signaled by the test suite, enabling team members to patch broken builds in an efficent manner, allowing the development process to continue smoothly. The use of integration testing was performed by running the System recommender in conjunction with other recommenders and the use of regression testing introduced after integration of the System recommender with the other units of code, unit tests served as regression tests for ensuring that existing functionality did not fail after using the system as a whole. The acceptance testing was conducted regularly throughout the development process at the frequent meetings with the customers. This involved displaying several arbitrary diners, chosen at random, with their recent bookings and generated recommendations displayed side-by-side as a means of comparision. Through such displays and further discussions with the client this was used to assess the sensibility of the recommendation system in relation to the expected behaviour as defined by the user stories agreed at the outset of the project (reference refinement of system requirements section 2) though a stronger emphasis on acceptance tests throughout the entirity of the project would have been of benefit to the team through continued assurance that the project was achieving the proposed requirements.

The test suite for the project was set up to run on Jenkins, a continuous integration environment. Automatic test cases were scheduled to run after each commit to the project's source code and in the event of failure the team would be instantly notified of a broken build. Through use of this system this enabled early awareness of issues and defects in the current build which signalled to the team that the build should be corrected prior to proceeding with new feature development. In addition to this Jenkins was also configured to provided coverage reports for the source files, indicating the proportion of the project covered by test cases. This was established through the Cobertura extension to Jenkins which provided the team with a detailed visual representation of the coverage reports, indicating the percentage of classes, conditionals and lines covered. Such reports, information and feedback were then used to drive the testing process through identification of which portions of the source code were in most need of testing.

Although the testing followed the general principles of the Extreme Programming test methodology the lack of any particular strategy lead to the discovery of several modules missing tests cases in addition to some tests utilising untested modules. By following a stricter, more systematic test plan such issues would have been avoided entirely. One particular ommitted type of testing which the team would have also like to incorporate would have been to utilise is mutation testing. Mutation testing could have been levereged through inspecting the test cases themselves to determine whether they are able to detect potential edge-cases in the source code.

The inclusion of stress testing would was highlighted as being of interest in order to inspect the behaviour of the engine as it processed varying sizes of data and the incorporation of performance tests  to the test suite would have also proved useful though consideration of their inclusion during the project's development found that such tests would be difficult to perform due to the direct dependency of the project with Apache Spark. This was primarily due to the potential speed of computing recommendations being maximised through alteration of the configuration of Spark to use multiple cores.  

The final area for improvement of the test procedure would have been to better incorporate statistical measures into the testing process. As machine learning is heavily reliant on such metrics to assess the quality of the system there exists a crossover between the internal evaluation loop of the recommendation system and the testing of the system itself. Of all potential tests considered for the project this was identified as being the most difficult and so the decision was made for the evaluation system to provide the statistical assurance of quality and accuracy of the system whereas the testing would focus more on the functionality of the system. Ultimately this proved quite successful for the development of the project as the team produced an accurate recommendation system and well tested system.

% Harsh questions that are partially answered
%
% Are there test strategies specifically for machine learning projects which could have been followed?
% 	Yes, I believe this goes back to evaluating and calculating mean squared error, this is what Paulus and Edward did.
% Could we have used test scenarios with and determined the levels of outcomes are acceptable for each scenario ?
% 	Determining 'levels of outcomes' is hard, not sure about this
% Could we have set objective acceptance criteria and established the amount of error you and your users are willing to accept ?
% 	Yes, setting acceptance criteria from the user stories would have been useful, but establishing the amount of error users are willing to accept is hard due to qualitative results from the engine.
% Should our testing have better utilised statisical measures in relation to the system accuracy?
%	Yes, the statistical part was tricky, that's why most testing resided withing unit testing.
% Could the testing have provided internal feedback on the efforts of the application. First, evaluate the application according to the acceptance criteria. Second, be prepared to support those assertions in statistical terms; for example, be 95 percent confident that the application will produce an answer within a given range. Last, have a high-level understanding of the underpinnings of the application, so that any deficiencies might be able to be ascribed to a particular application component.


\subsection{REFLECTION POINT - Team Structure}
\label{sec:teamstructure}
% ##################################################
% LAST EDIT:  25/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% REFERENCE: Developer Anarchy - article || paper on it
% REFERENCE: Sports model of team structure - roles
%
% Perhaps tie in the mythical man month refelction to the ending better as well
% ##################################################

% ################# References #####################
% References maybe hard for this section
% http://doras.dcu.ie/20469/1/MRP_SengNotes.pdf
% http://www.ambysoft.com/essays/agileRoles.html
% ##################################################

% I feel like I have written the words 'component' and 'aspect' a lot in this section

% Flow seems rough but the idea is that pure anarchy failed - role based system was adopted and here is why - reflect on why the role based system worked well

% Reflect on the transision from Anarchy to a sports model and how it improved the development efficency - improved communication / workflow / etc.

Initially the team elected to use an 'developer anarchy' team structure whereby any team member was free to work on whichever aspect of the system they were currently interested in working on. Despite being an unconventionally structure the team felt confident in our ability to effectively communicate and organise development resources. Anarchy also looked promising due all of the team feeling comfortable to work on both the back and front end functionality of the application as needed. Finally as the proposed system design allowed for concurrent development on different back end recommenders to occur the team believed that the anarchy development style was suited to the project.

During the December 8th retrospective which saw the closure of the first true development milestone, the team was optimistic about the team structure and felt a natural order had fallen into place. The team felt, however, that the organisation and communication could be improved as open communication regarding what developers where actively working on and opinions shared on completed work was absent. (This should have been a sign for code reviews). In addition it was highlighted that task allocation did not actively reflect what developers were actively working on and the team felt this too was adversely affecting the development efforts. Although measures were taken to refectify such behaviors, as is discussed in Section (LINK COMMUNICATION / TASK BACKLOG REFELCTION), at the next retrospective on January 26th it was highlighted that the same issues had occurred once more. Furthermore some team members began to feel underutilised and it was noted that components of the system, the front end, testing and content based recommender, had not seen as much attention as required. To combat this the decision was made to adopt the role based, sports model, of development structure as the team split into two separate development subteams, one to continuing building the recommendation engine and one to construct an improved front end display of the application. The team based this model off ... (reference sports + role model advice which the team followed) and chosen due to its prevalent use in industry (reference stats on this).

Although the roles would alter as development progressed as can be expected from adoption of this model (reference source) the team explicitly assigned one developer to lead development of each of the under development aspects of the system, the creation of the content based recommender, the design and development of the display application and the managing and creation of system testing, with the remaining developers left to lead the development of the existing components, documentation and research into future development work for the system. 

% Say why this model was used - Mythical Man Month / too many cooks in the kitchen - no point of us all trying to work on the ALS system at the same time (with or without branches)
The inspiration of the model of subdividing the team and further subdiving the recommendation engine components was in part due to the forewarning presented in The Mythical Man-Month text (reference). The focus of this text is to provide through case studies a warning against the assumption that adding more developers to a project will in turn speed up the development time of the project and so the team used this advice when setting up our organisational structure. Although the team were not behind schedule as is the general theme of the text, the lesson drawn by the team was the message of employing too many developers who all attempt to work on the same aspect of a system and how this subsequently delays and affects the end product. In addition to the structure subdivision of developers to adhere to this advice the general philosophy was established within the team to avoid "Too many chefs in the kitchen" and thus for developers to be mindful of if they should transision to work on another aspect that was not their primary focus of development. An incident of this which occurred early on in the new development structure was that it was originally proposed for the lead front end developer to assist with the creation of the content based recommender. However realising that this proposed development structure might in fact compromise the initial work of this component and thus delay its creation it was decided retract this role from the developer and refocus their efforts entirely on the display application and documentation of the system. % If you wish to quote to the book directly please use the line: "The bearing of a child takes nine months, no matter how many women are assigned. Many software tasks have this characteristic because of the sequential nature of debugging."

Embarcement of this model saw the productivity of the team vastly increase, partly due to the knowledge gained through working on the project for several months, primarily due to each major component of the system having a developer whose priority it was to lead development. 
% This is clunky but try to get across that roles created sub-experts within the team allowing other developers to know who to ask if an unfamilar part of the system was giving them trouble - Dom turned to Paulius for assistance in setting up tests for unfamiliar aspects, etc.
% Get across the idea that this project wasn't was one of the more complex projects from an implementation standpoint and so this system established a network of experts regarding the different aspects of the system. 
% After change to role system reflect on improvement to development (positive reflections)
While the team still embraced the anarchy philosophy of allowing developers to aid development of different components as desired, having lead section developers established expertise within the team of the various system components. This allowed created a communication loop where developers unfamilar with one aspect of the system knew exactly who to ask their quieries regarding the specifics of the implementation. This was extremely beneficial for the testing development as the lead system tester would often have a query regarding testing one specific aspect of the system and could get a rapid response through asking the lead feature developer about the specific thus reducing the time required to implement the test case which in turn improve the test developers efficeny. Additionally this system improved the feature specific testing as the lead developer fo the component could provide feedback to the tester regarding how to further improve and developer particular tests in order to better verify and test the system.   

% End with what the team learned - saw the dangers of too many developers attempting to work on same aspect and avoided it / how for more complex projects structure was needed and pure anarchy would not suffice.
Through experimentation of the development structure the team eventually found a system which they were comfortable with which resulted in development occurring at a steady pace. This occurred when the distinct, over-arching 'recommendation system' and 'display application' subteams were established and lead developer roles taken up regarding specific subcomponents of those larger topics. In part this decision to subdivide was a natural process as the first few months of 'developer anarchy' allowed the team to experiment with different sections of the development and gave developers the freedom to work on whatever component they believed to be the most important and interesting. Although not a traditional 'Scrum structure' the team found this initial approach to be beneficial when the time came to subdive into teams as the initial developer freedom saw some team members gravitate towards and away from some aspects of the development based off the past experience working with that particular component during the initial stages of the development. As such the team believes that the organisational transition from complete anarchy to a subdivision structure was a natural evolution as developers found the roles they enjoyed and believed they were of most use to the overall development of the project. Although the approach could have been taken to subdivide earlier or from the outset of the project, the team enjoyed the freedom to experiment during the initial stages of the project and view it as having a postive impact towards each developer's initial understanding of the system and how they might best be of use to a successful development process.
    

\subsection{REFLECTION POINT - Communication Breakdown \& Task Backlog}
\label{sec:communicationbreakdown}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:       First Draft 
% ################# Comment Log ####################
% Here I'm just trying to sum up some of the communication issues and suggest some ways of rectifying them

% Maybe it would be best to go more into detail on what improvements did occur but I don't know what that
% would be beyond "You we talked to each other more"

% Suggests the use of quick stand up style meetings and burn down charts as an easy fix to the problems faced
% ##################################################

% ################# References #####################
% Stand ups
% https://www.mountaingoatsoftware.com/agile/scrum/meetings/daily-scrum
% https://www.agilealliance.org/glossary/daily-meeting/

% Burn down charts
% https://www.scrumalliance.org/community/articles/2013/august/burn-down-chart-%E2%80%93-an-effective-planning-and-tracki
% http://www.agilenutshell.com/burndown
% ##################################################


An issue highlighted throughout the conducted retrospectives for the project was the issue communication between developers within the team. Although communication did steadily improve over the development period the team prior to entering the final development sprint the team did not believe it to be of the highest possible standard despite some of the highlighted issues being addressed and amended. 

What was found during the first retrospective was that the lack of focused development communication channel resulted in some loss of information between team members. To combat this the decision was made to organise a Slack channel for focused communication regarding the project's development. In addition to this it was also highlighted that only a subset of the developers were actively using the ticket management system (Trac) and so efforts were made to ensure the entirety of the team used the system in a consistent manner. This would see the introduction of some general team wide styling options, such as for commit messages and tickets, to ensure a consistent, clear style was  establish for use within the team. 

What would be seen a subsequent retrospectives follows on from the highlighted issues here of a lack of active communication between what developers were actively working on and a slow response rate to following through on the development work of assigned tickets. 

Considering the former issue what the team found they lacked throughout the entire development process was a lack of frequent communication regarding what team members were actively working on. This would subsequently play a small role in the issues which occurred in the integration of new features as outlined in Section (reference code reviews) though knowing the importance of working coherently in the final development sprint the team did achieve a higher standard towards the end of development which should occurred throughout the entire development process. 

In part the communication issues grew from the decision made to cancel the weekly meetings of the entire team which occurred during the initial stages of development. Partly due to the additional commitments of some team members restricting their availability times the decision was made to reduce the number of full team meetings in favour of an online focused communication system. This system would then reduce the number of full team meetings to preparation meetings for customer meetings, retrospective meetings at the end of each sprint and milestone planning meetings at the start of each sprint. And while some of the introduced methods such as team restructuring as discussed in Section (reference team restucturing section) and the use of pair programming as outlined in Section (reference pair programming section) did see an increase and improvement to the communication between developers the team still felt that active communication regarding development work could have been improved. One potential solution to would have been the use of code reviews as discussed in Section (reference code reviews) though an alternative solution would have been the introduction of weekly stand up meeting (reference something on stand ups and their benefits).

Although intended for daily use within industry, a down scaled version would suffice our need as the short duration could quickly establish what each developer did in the past week and towards which goal of the sprint, what the developer will do in the next week towards a sprint goal and are there any obstructions that the developer forsees preventing the team from attaining a set goal. Such meetings would have eliminated any uncertainty within the team of what each person was actively working on and each developer could then be held responsible for the work they claimed they intended to do the upcoming week towards the end goal of the sprint. 

An additional agile practice which could have been added to each meeting would have been the utilisation of burn down charts as a means of monitoring the team's progress towards the completion of the goals of the sprint. This would address the complaints seen with the team's use of ticketing where some tickets were highlighted as being actively worked on but their completion not achieve in a timely manner. By seeing the graphical representation of the current sprint's ticket progress followed up with each developer's own account of their past and active work it would become clear which task were recieving higher priority and which commitments the developer should relieve to another member of the development team to ensure a more timely completion.


\subsection{REFLECTION POINT - Code Reviews \& Branching}
\label{sec:codereviewbranch}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% Very, very, rough
% Struggling to explain why it appeared that commits were fine which were in fact broken
% REFERENCE: Good Agile code commit practices
% ##################################################

% ################# References #####################
% http://verraes.net/2013/10/pre-merge-code-reviews/
% http://haacked.com/archive/2013/10/28/code-review-like-you-mean-it.aspx/
% https://about.gitlab.com/2015/08/05/6-reasons-why-pre-is-better-than-post-production-code-review/
% https://thepugautomatic.com/2014/02/code-review/

% Software Engineering Recommended Course Textbook - Chapter 24
% ##################################################

% Lead in with explanation of why the system design was structured to create the best possible system and in part discouraged branching
From the outset of the project, knowing the importance the system design would have on the development of the project, the proposed design was constructed to achieve high levels of cohesion and low levels coupling within the system. As outlined in Section (reference to system design / models section) at the outset of development the team believed that the individual components, the evaluation system, collaborative and content based filters, in relation to system design where independent enough to allow for development to proceed without the need for development trunks. Rather the team felt adopting a branch heavy menatlity would discourage committing code due to additional time required to handle merge costs and decrease the rate of code refactoring within the project. Although this system of minimising branching did ensure speedy integration of code throughout the duration of the project it was not without its problems during that later stages of the development as are discussed below.

% Explain the problems of this system
As the development of the system progressed and the system complexity increased it was highlighted minorly during the third and significantly during the fourth retrospective was that integration of new code was becoming an issue. Specifically that new code was being added to a particular recommender which would break the system evaluator component in addition to code was often being commit which was unfinished and being refined. Obviously such behaviour is not good Agile practice (reference good Agile practice article) though a potential explanation for this behaviour was due to lack of test strategy in place (reference test reflection point) which would result in the newly added code appearing to function correctly within the existing system, by passing all of the integration tests, whereas in reality it had in fact broken another component of the system. This was due to the integration tests correctly checking the code would generate the recommendations but not that the code was functioning correctly with the evaluation system.

Unfortunately as a result of poor communication between developers (reference communication reflection) this would often lead to another developer's work being deleted in order to fix the broken build which would lead to conflicts within the team. Obviously such behaviour is not acceptable within a development team as was highlighted during the fourth retrospective meeting. To combat this behaviour it was agreed to not delete another developers code without discussing it and justifying it to the developer who wrote the code. Furthermore it was agreed to stop submitting non-functioning code which was still a work in progress. The suggested methods were suggested due to time restrictions placed on the team as the work entered the final development sprint and the proposed solutions did work in the short term. However such practices are neither proper nor are they long term solutions. 
% Explain why the above fixes worked in the short term but are not long term solutions

% Then explain why code reviews are the long term solution to the problem
Instead the standard industry practice of avoiding such internal conflicts is through the use of inspections and code reviews (reference use of code reviews in industry). As one of the key problems for integration was due to the testing suggesting a defect free integration conducting code inspections would have also highlighted defects with the system earlier. As stated in (reference Code Complete course textbook) "the average defect detection rate is only 25 percent for unit testing, 35 percent for function testing, and 45 percent for integration testing. In contrast, the average effectiveness of design and code inspections are 55 and 60 percent" which not only shows that regardless of if the testing was in place that the most effective method of ensuring proper integration would be to conduct the code review process. Although some measure of code review was conducted through the use of pair programming as discussed in Section (reference pair programming) this instead would have been to introduce pre-merge or post-merge code reviews to the project. Adoption of pre-merge reviews in particular would have flagged integration defects and issues earlier and avoided the need to delete code from the master branch in order to fix the build as was highlighted previously when discussing the issues with integration with the evaluation system. The methodology instead would be for new major development work on a particular recommender occurred on a branch. Prior to integration with the master branch a pre-merge code review would be conducted on the branch to be merged between the branch and lead evaluator developers. This would have in theory highlighted merge conflicts and defects in the code earlier and thus avoided the need for one developer to heavily modify anothers in order to amend the disfunctional system. Pre-merge code reviews would also have increased system integration knowledge (wrong wording but how all the componentes integrate and work together) and resulted also in better shared practices within the team, a more consistent code style and reduced the need for some refactoring to occur within the system. 

% End with the team should have done code reviews and wished they had looking back over the development. Although damage control methods mentioned above and pair programming to an extent were used in the short term to rectify issues the code reviews would have solved but that the team's solution was not long term. 
In retrospect the team discovered the benefits and need for code reviews first hand. Although the team effectively coped with the situation and problems which arose from not coducting pre or post merge code reviews such solutions were short term and would not suffice as a long term solution. Ultimately the decision to avoid branching influenced the team's belief for the need to conduct the code review process and as shown while it worked in the initial stages of development as the code base's complexity and interaction between components grew so too did the need for code reviews. Had the team the foresight to realise this then the code review process could have been introduced alongside the introduction of the pair programming process at the start the fourth development milestone.   


\subsection{REFLECTION POINT - Pair Programming}
\label{sec:pairprogramming}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% REFERENCE:  XP Programming Website
% REFERENCE:  Paper on costs and benefits
% REFERENCE:  Agile Allicance 
% Need to tie in references more but the content is largely here
% ##################################################

% ################# References #####################
% https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF
% https://www.agilealliance.org/glossary/pairing/
% http://www.extremeprogramming.org/rules/pair.html
% ##################################################

% Start with why the practice comes recommended
Lead in with a general statement about the benefits of pair programming to a development team (reference). 

% Knowing it comes recommended developers who have not already done it at work on a larger scale and more complex project wished to see how it would translate. How does it translate to actual development beyond the nature of an assignment which is designed to be solveable in a specific way.
Knowing that pair programming is a highly recommended development practice and having some rudimentary experience with the method through the second year JOOSE (yes tie this in better) laboratories some of the developers within the team wished to see how the practice would translate to a much larger and complex project, beyond the artifical designed nature of a academic task within the laboratory setting. Instead the developers wished to see how the practice translated to feature creation and development where the task need not have one particular designed solution in mind.

% Transision into the when, where and why of conducting the process
The decision for some of the developers to partake in this process was made in parallel to the team subdivision as is discussed here (reference). With this structure in place it made logical sense for the two developers wishing to conduct the process be on the same team and so both Josh and Joseph decided to handle the redesign and creation of the display application for the generated recommendations. Initially this started with the two developers meeting to create some GUI mockups for the proposed front end with the start of development work being identified as the best opportunity to conduct the pair programming process. As the team wished follow the development practice prototype of treating the first iteration of the display application as a throwaway prototype and incorporate the feedback and observations made into the redesigned iteration, the fresh start on development work was identified as the best opportunity to conduct the pair programming process. This development work stood out as there was no sense in both developers attempting the work simultaneously rather if used as a pair programming exercise the following benefits would be seen.

% Benefit one it increased coordination and reduced subsequent learning time of the system by the developer who didn't lay the foundations
Firstly pair programming reduces the coordination efforts required within a team since there are N/2 pairs to coordinate instead of N individual developers. As only two developers at this time were developing the display application through use of pair programming both developers knew the entire extent of the development work and the specifics of the system upon completion of the exercise. This allowed for more efficent individual development as both developers had created the foundation of the system and discussed where their individual development efforts would be focused next. 

Secondly as both developers strove for a well designed system foundation the connection between pair programming and better designed solution seemed obvious. As both developers brought differing levels of prior experience, one having more web devlopment experience than the other, saw an increased diffusion in knowledge among the developers which in turn reduced the potential for defects and poor design decisions in the early development work. Having multiple developers also introduced a larger number of potential solutions being proposed for specific problems than a single programmer can suggest. This allowed for discussions regarding which proposition would be the most suited for the long term development of the application and thus also increased the quality of the system's design.  
% Maybe tie in a specific example here but I can't think of one right now 

% Just a quick note on why it was beneficial from a learning perspective
Finally although pair programming should not be viewed as a student-mentor relationship (reference) conducting the pair programming process transfers skills and knowledge between developers by association. Performing this here was of great benefit to the less experienced web developer as he found he picked up on the minute techniques and broader skills used by the more experienced developer. Additionally as he was not faced with an the initial learning curve of attempting to jump in and understand a previously setup system he found he had a greater level of confidence to assist and experiment with development wherever possible.  

% End with its a process that the team wishes they had conducted earlier and more often and possibly suggest some features where it would have proved beneficial - one might be setting up tests for certain aspects of the system. 
Although it was used occasionally for debugging aspects of the display application and recommendation engine, the process as highlighted above for the creation of new features was only conducted once during the development cycle. Having seen the benefits suggested by (reference benefits papers) in real effect the particular developers involved and the team as a whole regretted not conducting the pair programming process more frequently during the development process. Had the team the opportunity to start afresh then pair programming would have been encouraged earlier and more often especially on the development of features such as A
% End with suggestion of where pair programming could have been used


\subsection{REFLECTION POINT - Dropping Features}
\label{sec:droppingreflection}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% Currently a pool of notes
% Two types of feature dropping:
%  1. Dropped due to straying from cutomer vision - new user recommendations
%  2. Dropped due to lack of time / project management / planning - recommendation reasons / system recommender saying contribution states from various other recommenders on the system recommendation / comparision of our system against other methods such as random guessing, etc - mention then fire off to relevant reflection point section 
% ##################################################

% ################# References #####################
% ##################################################

% For example, if you found that you had to drop a feature during an iteration, discuss the reasons why the feature had to be dropped. Had you given yourselves too much work? Was the feature harder to implement than you realised? Had you got your priorities wrong? Then consider looking at the literature (see the recommended reading for PSD3) on project planning and estimation. Was your experience typical of a software project? What steps do other developers advocate for improving estimation?

% General lead in regarding that feature dropping occurs for many reasons
The decision to drop a proposed feature from the development schedule of a software project can transpire for a variety of reasons. Examining the reasoning behind such decisions, however, provides an excellent insight and chance for reflection on the development process. Considering the features we decided to drop from development we see an example of both omission due to technical and time constraints in addition development scope creep away from the customer's vision and focus of the project. (reference something that these are two of the primary reasons for feature dropping)

% Talk about recommendation reason as a good feature dropped due to lack of time
% Possibly reference some case studies of similar industy sitations
% Reference away end with may have made development if cost estimation done
An example of the former reason for exclusion was the intended development of providing a metric of reasoning behind the generated recommendations such as stating which recommenders contributed most to the recommendations generated by the system recommender. Despite the team's desire to incorporate such a feature it was ultimately found to be too large a task to implement given the finite amount of time allotted to its creation towards the end of the development process. Instead it was decided that the time should be better spent on refinement of the generated recommendations from the existing system and refactoring the code. Had the team more time to work on the project then the decision would have been made to incorporate such this feature into the system although in retrospect its inclusion may have been possible had the team followed some of the cost estimation techniques described in Section (reference cost estimation techniques).

% Next hit on the features dropped as they were identified as scope creep
% New recommendations found to be search rather than user simularity - dropped as suggested by use when we lacked knowledge / underestimated complexity of the task
% Google maps - research work done but found via observations that the customer need not see this information and so time refocused. Perhaps if recommendation reasoning included then it might have justified the inclusion of this feature.
Within our project the team also made the decision to drop proposed features which were identified as being examples of scope creep introduced by the team. The primary example of this would be the team's initial idea to provide recommendations for new users as well as existing users. This was suggested at the start of the development process by the team and in hindsight was proposed at a time where the team had yet to fully understand the nature of the task, lacked the necessary knowledge to propose extensions and underestimated the complexity of the project. As such this suggestion, while sensible to both the customer and team at the time, is an example gold plating from the development team as additional requirements beyond what was necessary were introduced to the project by the team. Fortunately this feature, which would have taken a significant amount of development resources to construct, was identified as straying too far from the customer's vision of the system. What the team found during some low cost development work and prototyping was that recommendations generated to new users in the proposed manner would be made based off a search or filter system. Such a recommendation strayed from the customer's vision for recommendations to be made based off the simularity between users. Upon discovery of this knowledge the decision was made to drop the proposed feature from development as the resources required for its development were too great as the feature itself strayed too far away from the customer's desire for the system.  

A second example of the team proposing additional work beyond what was necessary within the project was regarding the display application for recommendations and the suggested inclusion of restaurant specific pages containing  additional information on the restaurant and a Google map picture showing where the restaurant was located in relation to the other suggestions and restaurants visited by the user. Once more this was during the initial design phase and was later identified through observations during a customer meeting that it would not be necessary and that merely refining the existing system beyond the list of recommendations with some additional information being provided. As such the decision was made once more to drop this proposed feature from development and refocus the saved resources to refining the existing application with the aforementioned improvements and ensuring the system was properly documented. 

% Lead out with a postive saying the team did well to identify scope creep early on and not waste development resources. If anything proposing all these extra features was due to the creativity within the team and excitement of working on the project
Ultimately although the team was forced to drop a desired feature due to lack of time, the primarly source of feature dropping was due to the introduction of scope creep within the project. In this sense the team performed well because although the additional requirements were suggested for development, largely due to the excitement during the initial stages of development, upon researching the propositions the team were aware enough to realise the features strayed from the customer's primary focus for the system. Consequently the decision was made to drop the features from development and refocus the saved development resources on aspects of the system which did not divert from the customer's intent and thus the team sucessfully avoided wasting development resources on unnecessary development work beyond what initial research work was conducted. 


\subsection{REFLECTION POINT - Cost Estimation and Task Backlog}
\label{sec:droppingreflection}
% ##################################################
% LAST EDIT:  26/03/17  Joseph
% NOTE:         Temp notes / thoughts
% ################# Comment Log ####################
% I have no real idea where I'm going with this section
% ##################################################

% ################# References #####################
% Cost Estimation
% Chapter 23 - Software Engineering Textbook Recommended in Course
%
% Planning Poker
% https://wingman-sw.com/articles/planning-poker
% https://www.mountaingoatsoftware.com/agile/planning-poker
% ##################################################

% Talk about why cost estimation is good for a project
Cost estimation...

% I have no idea how to lead into this topic
Refelecting over their time on the project the team believes that the lack of formal cost estimation techniques had a determentally effect on the project. (Reference all the reflection subsections where I've off loaded cost estimation as an issue and area for improvement). Rather than use a formal cost estimation method, as is outlined below, the team instead chose to simply establish a common understanding of which tasks per sprint should be prioritised for completion and which would require the most developer resources to complete. While such as system did see the completion of the most important tasks per sprint it also saw the several tasks be put on backlog and ignored and thus pushed to into the next development sprint. 

% Get across the idea that planning poker would have solved issues
To combat such behaviour the use of a cost estimation technique, such as planning poker (reference to planning poker), each sprint would have better highlighted the cost and time estimates for each task per development sprint. This would have given a better estimate of the workload assigned to each developer and highlighted potential situations where one developer had committed to a greater amount of work than was feasilbe for a particular sprint. This would have allowed other developers to step and and reduce over committed developers workload and thus increased the throughput of completed tasks per sprint. Additionally planning poker would have assisted and encouraged the creation of the burn down charts as proposed for use in Section (reference communication section) which would have aided the team's task management and thus benefitted the team in multiple development channels. Had such techniques been introduced from the outset of the project then the development time may have been found to include dropped feature of generating reasons for recommendations as is discussed in Section (reference dropped feature section) as the team would have been better prepared to manage the finite free development resources available towards the end of the development cylce and found the needed resources to develop the feature for inclusion within the final system. 


% HERE DOWNWARDS ARE MISC NOTES
% Requirements Engineering:
% (Lecture 13) Requirements gathering is an ongoing iterative process that runs concurrently alongside requirements analysis and capture - our project saw this in real effect due to the changing nature of the requirements of our project.
% (Lecture 14) Requirements engineering is an iterative process of elicitation, capture and validation - talk about how we did this to ensure we were gathering the correct requirements.
% (Lecture 3) Causes of software project failing - building system for wrong reason, building the wrong system, building the system wrong. We could tie in the dropped new user recommendation to a proposed goal which was later determined to be a requirement which would be built for the wrong reason. As such the feature was dropped to avoid building an incorrect system.
% (Lecture 13) Cultural differences between engineers and customers - although the developers were technical they don’t know anything regarding machine learning or the development of a system such as ours - Requirements Risk
% (Lecture 13) Vague requirements specification of end state of system / customer uncertainty regarding the final state of the system - Requirements Risk
% (Lecture 13) A means of investigating poorly understood requirements (prototyping) - Managing Requirements Risk - perhaps we could have prototyped both a front end display and an integration method / discussed this with the customer earlier. This would have defined a determined end state of the system prior to January which would have allowed for an earlier split in development focus and resulted in either integration or improved front end. Granted one must also consider that technical decisions were still ongoing at this time.
% (Lecture 13) Requirements evolution - occurred when we discovered potential features which were ultimately dropped (new user recommendations)
% (Lecture 14) Avoid early commitments to particular design solutions during requirements elicitation

% Communication:
% Slack was set up and made the dedicated communication channel for project communication.
% Despite having a Slack communication remained somewhat poor.
% Decision made to ensure tickets actively represent what feature of the system you are working on.
% Ticket system improved but commits / development did not occur in a time efficient manner.
% Sub teams additionally helped communication within front end and back end through team communication as a whole was still somewhat lacking.
% Specific incident - Edward not providing data sent from customer in a timely manner.
% Part of team felt agreeing to meet up in person at least once a week to work on project was a waste of time / resources - this had an adverse effect on communication that wasn’t addressed. Instead majority of team met up once a week at scheduled time as some developers strayed through the valley of the shadow of death into the unknown.
% Perhaps Joseph focusing less on development taking on a purer scrum master of role would have improved the development though it due to this being an academic project that the team felt that not suitable or possible as everyone should have played an active role in development.
% Talk about the benefits a product owner would have had on the development of our specific project - improved efficiency of tackling task backlog (tasks were avoided from one milestone to the next)
% (Lecture 7) Perhaps burn down charts per sprints would have been a good idea and would have improved prediction of task completion, backlog management, communication and prioritisation of backlog tasks.
% Pair programming increase communication and coordination greatly - positive
% Subteams increased communication a lot as well - postive

% Code Reviews:
% The system was designed such that branching was unnecessary for the project. Branching was somewhat discouraged throughout the project in order to reduce merge costs / time. Whether the time saved outweighs the time spent fixing and altering other people’s code remains to be seen.
% Lack of code reviews meant that the code often had inconsistent styling.
% Lack of code reviews meant a significant portion of time was spent fixing or altering other people's code to work with parts of the system they did not realise they had broken.
% Lack of code reviews meant code which was WIP was deleted prior to it being fully implemented into the system - again lack of branching issue somewhat.
% Suggested at the first retrospective but ended up avoiding. Would have reduced a number of problems with development cycle but you can't be perfect.
% Highlighted in retrospective 3 with the code integration being highlighted.
% Highlighted even more in retrospective 4 with code integration really being highlighted.
% Reference potential methods or strategies for code reviews which could have integrated into the development.
% Reference how other and often professional developers recommend doing code reviews.
% Mention that pair programming was conducted and the benefits of doing it. Mention it should have been conducted more frequently, reference that it was beneficial when suggesting if XP was potentially better than Scrum.
% Code reviews might have improved development efficency as less time spent refactoring and fixing broken code. Reduced arguments caused due to deleting other people's code prior to full implementation. Branching also would have fixed this as only get back to master upon passing all tests. This would require testing to have been more efficent as well thus suggesting test strategy should have been utilised to improve test efficency.
% (Lecture 26) Outline of inspection methods - should probably mention which we should have used in the code reviews.
% (Lecture 8) Change management and the conflicts caused from developers working in parallel and contributions are made to the master branch which are not fully implemented or break some aspect of the system. In hindsight this probably should have justified a separate branch which would be integrated into the master upon passing all of the tests with a successful build in Jenkins the continuous integration system.

% Cost Estimation:
% This comes up a lot and should be its own reflection point
% Discuss that it was not properly conducted and explain the benefits of employing it
% Talk potential cost estimation techniques we could have employed (planning poker)
% Discuss what other developers advocate in this regard and how they could have been incorporated into our project

% Misc:
% (Lecture 19) Throw-away front end prototype was used and was good as it gave a better understanding of the requirements the front end would require upon it becoming the final state of the system. This knowledge and the discovered failures fed into the redesigned system and so the throw-away prototype was very beneficial to the project. (MINI REFLECTION POINT ?)
% (Lecture 19) Prototyping is used to reduce risks caused by uncertainty in software projects, not introduce more risk - to some extent this was done for components of the back end system as well.
% (Lecture 30) Formal specification is a specific thing so probably don't just refer to a specification document as being formal loosely.
% (Lecture 32) Refactoring is an important process which went on over the course of development.


% -- OLD TECHNICAL LEAD IN SECTION --
% This section should be a mainly postive reflection of the technical choices of the project.

% The occasional limitation can be mentioned in the passing such as the use of Python scaring the customer off integration (theory) 
% and the drawbacks of the collab not allowing for training based on only new data (this if anything is a requirements engineering failure
% that could have been picked up earlier but customer did not consider until after seeing operation of prototype and use of data in its creation)
% Spark was fine. I have no gripes about using Spark.

% 1. Talk about why the technical choices are significant development points in the software development process.
% 2. Talk about how preemptive commitment too early is bad and should be avoided - reference case study - saying team used this as an warning. Use this as reference throw over to requirements engineering reflection point. 
% 3. Introduce the three major technical decisions of our project
% 4. Tie in testing and use as a reference throw over

% Preemptive commitment to particular design choices too early in the software development cycle leaves a software project at high risk of failure (reference a case study where an incorrect design decision lead to failure - lecture 1 / 3 recommended reading?). Summary of how this system failed in relation to incorrect design choice. 

% Say the team used this as a warning for the major design decisions - Development language, Models, Spark - that were involved with our project which are detailed below.

% State how the technical choices do not occur in isolation rather they are heavily work with the requirements gathering stage (reference lead in)

% Additionally discuss how they are related to the testing of the system (reference lead in) 
 
% However the technical choices of a software project are not made in isolation rather they are heavily influenced by the requirements engineering process of the 


% -- OLD SCRUM LEAD IN SECTION --
% Lead in with a general why Agile is used for large projects such as ours.
 
% As is often a common practice in industry (get a reference backing up claim) the team did not adhere strictly to one specfic agile framework. Instead the Scrum methodology was used as the overarching framework with additional agile practices from alternative methods, such as prototyping and extreme programming, being adopted as the team felt their use necessary and applicable. While this behaviour ensuresd a flexibile production envirnoment and the team found modertate success with the loose methodology it was not without its issues. Primarily this was due to the lack of discipline within the team to hold all of the key Scrum methods, as weekly stand up style meetings were cancelled in favour of a more open source style of development environment, and roles, as the team employed no product owner role and the scrum master was additionally on the development team. 

% Ultimately this would come at a cost of the teams ability to collaborate effectively on the project as the lack of stand ups led to communication issues as is discussed in Section (reference communication issue). Additionally the lack of product owner and focused scrum master roles played into some disfunctionality within the team organisation structure as highlighted in Section (reference team structure). By not conducting incomplete work and priority reviews at the each sprint's end the team inevitably saw proposed features be dropped as is discussed in Section (reference dropping features) and examined more thoroughly in Section (reference backlog management). This however may also be a consequence of the lack of formal cost estimation procedures conducted during the project as examined in Section (reference cost estimation) and not the teams approach to the Scrum methodology. Finally the issue of if whether such failures could have been avoided through use of a different agile framework, the Extreme Programming framework, is considered in comparision to following the Scrum methodology more strictly and closely than was conducted by the team in Section (reference stricter Scrum vs XP - final reflection point).


% -- I don't know if the requirements engineering section is needed or entirely relevant (certainly saves word count) --
% -- At this point its all just words to me anyway --

% \subsection{REFLECTION POINT - Requirements Engineering}
% \label{sec:teamstructure}
% ##################################################
% LAST EDIT:  20/03/17  Joseph
% NOTE:       First Draft
% ################# Comment Log ####################
% - References the cost estimation reflection point as an improvement - tie those two together
% - References scenarios which flows to testing via test scenarios / acceptance testing - ties those two together
% Reference back in subsequent reflection points to reduce lead in repetition 
% ##################################################

% Perhaps tie in the requirements risks and perhaps suggest methods of dealing with such risks via papers

% Basically we've reflected on the technical choices now why was it important that the requirements were engineering properly to better inform the technical choices and what could have been done to do this process even better

% From the outset of the project the team were aware of the need to properly capture the requirements of the project. It is widely documented that two of the primary reasons for software failure is due to building the wrong system and building the system incorrectly (said in lecture 3 - get academic proof) both of which were major threats to the development of our project. The team was mindful of how easily building an incorrect system, one not based off similarity between users, or selection of the incorrect machine learning model and subsequent project failure could occur in our project. 

% Adhering to the advice of avoiding early commitment to a particular design solution during the requirements elicitation process as is discussed in Section (reference case study reflection at technical overview point) the team left the decision regarding the specific models and tool choice until after this phase was conducted. Although the requirements would evolve as the project developed, as is to be expected, the team felt with the correct initial system goals established the team could easily justify decision designs in relation to the key goals of the system. Such technical decisions, specifically the choice of development language, machine learning models and clustered computing framework, are discussed in Sections (reference all three technical reflections) respectively. 

% Knowing the significance of the requirements engineering process for the sucessful development of the project, the team dedicated the first milestone to ensuring the proposed system to be built was correct. This occurred in parallel with technical research into similar systems and their creation (reference Netflix research from section 2). To ensure the team captured all functionality of the system the team, having conducted the initial customer interview, prepared a requirements specification document which was later refined through customer discussions (reference section 2 requirements section). 

% Within this document the team elected to use the user stories method of requirements specification in order to create an all encompassing set of stories which reflected the proposed features and functionality of the system. As the recommendations are made to ResDiary customers the team felt user stories provided a good a boundary artifact between the proposed users, customers and developers (taken from PSD lecture 15 key point) and that user stories were a natural choice opposed to alternative specification techniques such as use case diagrams because… 
% Try to sell the idea that user stories are the natural choice for our project as user stories are written from the customer perspective and the recommendations are being made to the end customers

% Although some modifications were necessary, as is to be expected, the team found that proposed the user stories modelled the customer requirements with a good level of accuracy (reference section 2 refinements after initial meeting). In addition to this the additional proposed features, generating recommendations for new users and the ability to recommend previously visted restraunts, that the team suggested were recieved with good feedback by the customer. They believed such features tackled aspects of the problem they themselves had not yet considered and felt we had a good understanding of the system. 

% Establish that task estimation was not properly conducted then reference away to specific reflection into that topic
% One shortcoming of the use of stories however was the measure of priority attached to each user stories and the subsequent task breakdown by association. The team did not conduct a formal task estimation procedure beyond the breakdown of the user stories into smaller, more general tasks. This was in part due to the lack of technical knowledge into the subject area from the team at this stage in development though the team should have conducted proper task estimation to assist with project planning and management as is discussed here (reference planning and cost estimation reflection point). 

% Transision into this better and potentially expand on
% Another area of improvement in the requirement gathering process would have been the inclusion of use scenarios in the “Given, When, Then” format. This is a natural progression of user stories as it expands upon an individual story to provide an example of it in action. Such scenarios could then be utilised to allow for further refinement discussions to occur with the customer in order to better establish conditions for system acceptance which would improve the acceptance tests of the system and allow for scenario testing to be conducted on our system. A discussion regarding such tests and other methods of improvements is discussed in Section (reference testing)  

% Tidy up the ending better - more postive - team did well in this regard and so should end on positive note
% Although the aforementioned could have utilised to improve the team's cost estimation and test process for the project, the team established a good understanding of the customer's vision and corresponding system requirements. This ultimately showed during the various customer demonstrations where by second to last meeting they encouraged to the team to follow where we saw the development of the system going as they were already impressed and pleased with the results. This level of confidence placed in the team we feel showed we had a good initial grasp of the system and thus were able to deliver and take steer the project in the direction we saw it heading towards the later stages of the project. 


%==============================================================================
\section{Conclusions}
\label{sec:conclusions}
% ##################################################
% LAST EDIT:  
% ################# Comment Log ####################
% ##################################################

% A conclusion that draws general and wider lessons from the case study (approximately 1-2 pages)

% Explain the wider lessons that you learned about software engineering, based on the specific issues discussed in previous sections. Reflect on the extent to which these lessons could be generalised to other types of software project. Relate the wider lessons to others reported in case studies in the software engineering literature.

All our negatives are positives.

The team saw the benefit of frequent prototyping which resulted in a display application that presented the information very well to the customer. This reinforced through real, practical experience that the ideas presented in software literature of rapid and frequent prototpying have a postive effect on the development efforts.

The importance of code reviews, even when not dealing with branching systems, was encountered by the team and would have avoided tensions towards the end of development. Had the team the chance to start the project afresh then such practices would certainly have been integrated into the team's process.

The importance of testing, especially combined with continuous integration for non-complex systems, was seen by the team.

The team faced the real world problem of scope creep within a project and had the awareness and foresight to recognise occurrences of it and drop the features from development.

The team discovered the flexibility of Agile practices found by not strictly following any one particular methodology. Although this did result in at times poor cost estimation and communication had such measures that are highlighted in Sections (reference cost est. and communication) then the troubles faced by the team would largely be avoided.

The importance of making the correct initial design decisions, avoiding jumping into the development and conducting the proper research was highlighted to the team as making an incorrect design choice of model and committing to development too early would have resulted in a development time too short to create a good functional system. Instead the team selected the correct choice of model which reflected in the accurate output of the system.

This also reinforced the importance of requirements engineering because without a good grasp of the customer's intent the team could have easily built the wrong system which would have resulted in software failure -- there's a link between this point and one of the early lectures in the course.  

%==============================================================================
\bibliographystyle{plain}
\bibliography{dissertation}
\end{document}
